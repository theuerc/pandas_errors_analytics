[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.0, pluggy-1.2.0
rootdir: /home/pandas
configfile: pyproject.toml
plugins: hypothesis-6.80.0, cython-0.2.1, xdist-3.3.1, localserver-0.7.1, asyncio-0.21.0, anyio-3.7.0, cov-4.1.0
asyncio: mode=strict
collected 2443 items

pandas/tests/io/test_sql.py FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF...FFFF....FFFF...FFFF...FFFF...FFFFFFFFFFFF.................................................................................................................................ss..............x.....................................................ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.......................
pandas/tests/io/parser/test_network.py ................ssss.....EEEEEEEEEEFExxEEEE
pandas/tests/io/test_fsspec.py ............EEEEEs............
pandas/tests/io/test_parquet.py ......................................x......................EEEE..............xxxxxx...............E......................
pandas/tests/io/test_s3.py .EE
pandas/tests/io/excel/test_readers.py ..............................x.......x.....................................xxxxxx............................x.......x...............................................................................x.......x.......x.................................s..s..s.s..s..s.s..s..s.s..s..s.s..s..s.........................ssssssssssssss...................................................xx.xxx.......x.........................................................................................EEEEEEEEEEEEEEEE......................................x.......x.............xx................................x.......x.......................................................................................................................xs......xs..............................................................x.......x.......................................................................................................................x...............xs...sss..
pandas/tests/io/excel/test_style.py ...................................................................................................................................E
pandas/tests/io/json/test_compression.py ........EEEEEEE...............................................
pandas/tests/io/json/test_pandas.py ...........................................................................................................xxxx................................xxx.................................................................................................................................................................E........x................................................................xx.............E.....x...........................................
pandas/tests/io/xml/test_to_xml.py ......................................................................s...............................................................EE

==================================== ERRORS ====================================
_____________ ERROR at setup of TestS3.test_parse_public_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff764f9ba0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff767abf40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-985e65e6-aa45-443d-8d1a-e0a...nvocation-id': b'2a1c6c56-ae1d-4fdb-b77e-de8a2f418497', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff764f9ba0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff764f9ba0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff767abf40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-985e65e6-aa45-443d-8d1a-e0a...nvocation-id': b'2a1c6c56-ae1d-4fdb-b77e-de8a2f418497', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-985e65e6-aa45-443d-8d1a-e0aa20b16e43"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_private_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76871060>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff7616f910>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-a219065f-68fa-4167-b7e9-6ae...nvocation-id': b'2d5bdb7c-ef87-407d-b4f9-0d476ce7e978', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76871060>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76871060>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff7616f910>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-a219065f-68fa-4167-b7e9-6ae...nvocation-id': b'2d5bdb7c-ef87-407d-b4f9-0d476ce7e978', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-a219065f-68fa-4167-b7e9-6aef0d119a9d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3n_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76513100>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3ad780>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fc9e4099-e33f-44b1-85b4-db4...nvocation-id': b'ea111b7d-8f59-4948-9316-a686da1f84c9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76513100>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76513100>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3ad780>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fc9e4099-e33f-44b1-85b4-db4...nvocation-id': b'ea111b7d-8f59-4948-9316-a686da1f84c9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-fc9e4099-e33f-44b1-85b4-db40af0532d6"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3a_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fc6d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f2d5960>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-426f65e2-881d-4714-b8e4-3f7...nvocation-id': b'3ad9baaa-2e75-46c1-a658-4e82e21e13f1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fc6d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fc6d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f2d5960>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-426f65e2-881d-4714-b8e4-3f7...nvocation-id': b'3ad9baaa-2e75-46c1-a658-4e82e21e13f1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-426f65e2-881d-4714-b8e4-3f7c274debcf"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762e97b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff7700de40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-708e45d0-d06a-43b7-86c2-5e4...nvocation-id': b'3ff602dc-c755-4f18-8613-6d984151b0d1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762e97b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff762e97b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff7700de40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-708e45d0-d06a-43b7-86c2-5e4...nvocation-id': b'3ff602dc-c755-4f18-8613-6d984151b0d1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-708e45d0-d06a-43b7-86c2-5e4046efbd67"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762142e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff754cf8e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-eae77f15-33aa-4655-9914-019...nvocation-id': b'04c635cc-e5d9-499a-981a-e1da47a6ffc5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762142e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff762142e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff754cf8e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-eae77f15-33aa-4655-9914-019...nvocation-id': b'04c635cc-e5d9-499a-981a-e1da47a6ffc5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-eae77f15-33aa-4655-9914-0194c96826e5"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked_python ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7652f760>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff764af340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6487346b-79c4-40b2-a980-b69...nvocation-id': b'4e73f212-e6fb-4e5c-877f-02b32d649ab4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7652f760>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff7652f760>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff764af340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6487346b-79c4-40b2-a980-b69...nvocation-id': b'4e73f212-e6fb-4e5c-877f-02b32d649ab4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6487346b-79c4-40b2-a980-b696c68a467f"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_python __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557df00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff762cf190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e5452121-14e1-4a0e-a388-839...nvocation-id': b'4748138e-1476-441d-acf2-20ceec3a6aa3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557df00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557df00>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff762cf190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e5452121-14e1-4a0e-a388-839...nvocation-id': b'4748138e-1476-441d-acf2-20ceec3a6aa3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e5452121-14e1-4a0e-a388-839d809aa228"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of TestS3.test_infer_s3_compression ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f109c30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff75fc8fa0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-32863d1e-fdb1-40c7-9b15-024...nvocation-id': b'b85910b5-7cb2-4a02-a14d-bb07192baac9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f109c30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f109c30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff75fc8fa0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-32863d1e-fdb1-40c7-9b15-024...nvocation-id': b'b85910b5-7cb2-4a02-a14d-bb07192baac9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-32863d1e-fdb1-40c7-9b15-024369c65a86"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows_python _______

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff74f84e20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76efc8e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-328fd5bf-0852-491e-ac74-433...nvocation-id': b'a9bd928f-9193-48df-a3a9-3066c1e67a3f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff74f84e20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff74f84e20>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76efc8e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-328fd5bf-0852-491e-ac74-433...nvocation-id': b'a9bd928f-9193-48df-a3a9-3066c1e67a3f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-328fd5bf-0852-491e-ac74-43308e13de3e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________ ERROR at setup of TestS3.test_read_s3_fails_private ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff767a85e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e502620>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-e9bc09a9-8b50-445b-b8fd-ec9...nvocation-id': b'3f31ed43-e4aa-426a-8986-05fd67c66a6c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff767a85e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff767a85e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e502620>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-e9bc09a9-8b50-445b-b8fd-ec9...nvocation-id': b'3f31ed43-e4aa-426a-8986-05fd67c66a6c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-e9bc09a9-8b50-445b-b8fd-ec9f59c2a140"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
________ ERROR at setup of TestS3.test_read_csv_handles_boto_s3_object _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4b0a00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e09d4e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f03c9ec6-6c55-48dd-829b-6d4...nvocation-id': b'71a8c30c-7e5e-4a61-af9c-7f80ca4bb15f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4b0a00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4b0a00>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e09d4e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f03c9ec6-6c55-48dd-829b-6d4...nvocation-id': b'71a8c30c-7e5e-4a61-af9c-7f80ca4bb15f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-f03c9ec6-6c55-48dd-829b-6d4ac36c2f62"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_csv_chunked_download ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f2637c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-be325bda-8ed8-4343-b849-3ea...nvocation-id': b'585078e0-4201-4f51-93a5-d4af2cbdb869', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f2637c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-be325bda-8ed8-4343-b849-3ea...nvocation-id': b'585078e0-4201-4f51-93a5-d4af2cbdb869', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-be325bda-8ed8-4343-b849-3eaa9ce136eb"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_read_s3_with_hash_in_key ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e644b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3acac0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7a0f1499-d673-4f7a-8f6f-6fe...nvocation-id': b'9985ebc4-fb1b-4589-ad0d-a4b828a33dc6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e644b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e644b20>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3acac0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7a0f1499-d673-4f7a-8f6f-6fe...nvocation-id': b'9985ebc4-fb1b-4589-ad0d-a4b828a33dc6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-7a0f1499-d673-4f7a-8f6f-6febb15a1cba"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_feather_s3_file_path ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff75539c60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff767a9c60>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e546ce6d-1f51-4f4b-94fd-6ac...nvocation-id': b'1f424b97-4c2b-464a-88fd-58e34dba22e4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff75539c60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff75539c60>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff767a9c60>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e546ce6d-1f51-4f4b-94fd-6ac...nvocation-id': b'1f424b97-4c2b-464a-88fd-58e34dba22e4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e546ce6d-1f51-4f4b-94fd-6acff359c7aa"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________________ ERROR at setup of test_from_s3_csv ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76904e80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f108ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-34141ec5-4c57-4a47-9e37-7ab...nvocation-id': b'e03965c1-a0b3-4129-989b-83212859c0f0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76904e80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76904e80>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f108ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-34141ec5-4c57-4a47-9e37-7ab...nvocation-id': b'e03965c1-a0b3-4129-989b-83212859c0f0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-34141ec5-4c57-4a47-9e37-7ab6ddead130"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6ecb4a90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4c17e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-83103653-2061-44da-b9a0-27b...nvocation-id': b'c78a0181-2464-48ba-835a-61eff41ea214', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6ecb4a90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6ecb4a90>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4c17e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-83103653-2061-44da-b9a0-27b...nvocation-id': b'c78a0181-2464-48ba-835a-61eff41ea214', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-83103653-2061-44da-b9a0-27bcd091f45a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3a] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff763f3f40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff767fca90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-85071853-6fb9-4201-b998-06b...nvocation-id': b'd8935657-35be-4929-a51a-d42c61265871', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff763f3f40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff763f3f40>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff767fca90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-85071853-6fb9-4201-b998-06b...nvocation-id': b'd8935657-35be-4929-a51a-d42c61265871', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-85071853-6fb9-4201-b998-06b52876446c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3n] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1d50>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76e9b790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ec8a5612-f0fd-4359-87ce-721...nvocation-id': b'31966a41-04e0-4f24-b004-d4961f7e1747', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1d50>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1d50>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76e9b790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ec8a5612-f0fd-4359-87ce-721...nvocation-id': b'31966a41-04e0-4f24-b004-d4961f7e1747', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ec8a5612-f0fd-4359-87ce-72146f0aeb17"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________________ ERROR at setup of test_s3_parquet _______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6df13fd0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff7557f1f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-df304330-60af-46f1-ad53-66a...nvocation-id': b'dfdde17d-6197-4b5d-96f7-b4199133b6f2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6df13fd0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6df13fd0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff7557f1f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-df304330-60af-46f1-ad53-66a...nvocation-id': b'dfdde17d-6197-4b5d-96f7-b4199133b6f2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-df304330-60af-46f1-ad53-66a360f814d5"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_explicit_fs ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e5cd300>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e00cbe0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-456e858f-e694-4fcc-adc7-c23...nvocation-id': b'9e588e2f-2d48-40f8-b049-6d05d13e67f7', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e5cd300>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e5cd300>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e00cbe0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-456e858f-e694-4fcc-adc7-c23...nvocation-id': b'9e588e2f-2d48-40f8-b049-6d05d13e67f7', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-456e858f-e694-4fcc-adc7-c231638440e1"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff753d3220>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6ecb52a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dad7f410-1310-4c65-a133-6bc...nvocation-id': b'4d9b4bf8-6614-4c23-bc40-5b28bed1dfae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff753d3220>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff753d3220>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6ecb52a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dad7f410-1310-4c65-a133-6bc...nvocation-id': b'4d9b4bf8-6614-4c23-bc40-5b28bed1dfae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-dad7f410-1310-4c65-a133-6bc79aaa7016"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col0] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d7ac0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f323130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5247cc7f-8908-4b71-ad4e-bcd...nvocation-id': b'2087530f-03f2-452b-8d25-358891cea576', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d7ac0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d7ac0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f323130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5247cc7f-8908-4b71-ad4e-bcd...nvocation-id': b'2087530f-03f2-452b-8d25-358891cea576', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-5247cc7f-8908-4b71-ad4e-bcdaffd790e6"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col1] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4a7d30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e5d28c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5de33049-9b6a-4d9c-8345-0a5...nvocation-id': b'eec5fefa-b258-4c05-bdb9-4e00d8312485', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4a7d30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e4a7d30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e5d28c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5de33049-9b6a-4d9c-8345-0a5...nvocation-id': b'eec5fefa-b258-4c05-bdb9-4e00d8312485', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-5de33049-9b6a-4d9c-8345-0a53e118e2a3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestParquetFastParquet.test_s3_roundtrip __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76e705b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76086e90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5cb56269-4a07-45af-a946-fc4...nvocation-id': b'ddd3e95c-d3d0-401d-bb65-d93660d86549', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76e705b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76e705b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76086e90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5cb56269-4a07-45af-a946-fc4...nvocation-id': b'ddd3e95c-d3d0-401d-bb65-d93660d86549', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-5cb56269-4a07-45af-a946-fc4d43214c73"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of test_read_without_creds_from_pub_bucket ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e73c400>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76f66080>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dc04f1d2-b5f9-4599-85f6-7bd...nvocation-id': b'0ec95709-9d12-42a3-8939-d75a6117bdea', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e73c400>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e73c400>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76f66080>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dc04f1d2-b5f9-4599-85f6-7bd...nvocation-id': b'0ec95709-9d12-42a3-8939-d75a6117bdea', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-dc04f1d2-b5f9-4599-85f6-7bde38cf8a55"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of test_read_with_creds_from_pub_bucket ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1cc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e5d0190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-067005c2-e71d-4eef-8f36-877...nvocation-id': b'4ddb7093-5600-4271-8abe-62fcfe824917', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1cc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d1cc0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e5d0190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-067005c2-e71d-4eef-8f36-877...nvocation-id': b'4ddb7093-5600-4271-8abe-62fcfe824917', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-067005c2-e71d-4eef-8f36-87770f5cf652"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_url[('xlrd', '.xls')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff75512b30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e38ebc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-722576ee-1ded-4258-9bdc-5db...nvocation-id': b'484cdd20-22b7-462e-92c0-d4aed728b87a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff75512b30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff75512b30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e38ebc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-722576ee-1ded-4258-9bdc-5db...nvocation-id': b'484cdd20-22b7-462e-92c0-d4aed728b87a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-722576ee-1ded-4258-9bdc-5db131640912"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsx')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff753a7fa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4c2d10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5ba63a88-4c36-4958-81ad-ba5...nvocation-id': b'd9123046-42ac-4225-99f3-13aead4f6ce9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff753a7fa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff753a7fa0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4c2d10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5ba63a88-4c36-4958-81ad-ba5...nvocation-id': b'd9123046-42ac-4225-99f3-13aead4f6ce9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-5ba63a88-4c36-4958-81ad-ba5baede4da3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsm')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7618a650>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e38eb90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-12ee060b-df32-4274-bdf3-37b...nvocation-id': b'228d862a-73e0-47e5-8852-839b9eb2c81e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7618a650>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff7618a650>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e38eb90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-12ee060b-df32-4274-bdf3-37b...nvocation-id': b'228d862a-73e0-47e5-8852-839b9eb2c81e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-12ee060b-df32-4274-bdf3-37b93700a74d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xls')] ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3a30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6dc7b190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1bbbfbb3-3a44-4552-8f7b-24f...nvocation-id': b'a01594d4-df25-454e-876b-7c5caffc482a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3a30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3a30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6dc7b190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1bbbfbb3-3a44-4552-8f7b-24f...nvocation-id': b'a01594d4-df25-454e-876b-7c5caffc482a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1bbbfbb3-3a44-4552-8f7b-24ff280559fd"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsx')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751123e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4a5ba0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6c1b7e61-9246-4ca0-a1d6-2a4...nvocation-id': b'afb1617f-b3ae-47cb-90d0-3c10ef6cd755', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751123e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff751123e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e4a5ba0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6c1b7e61-9246-4ca0-a1d6-2a4...nvocation-id': b'afb1617f-b3ae-47cb-90d0-3c10ef6cd755', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6c1b7e61-9246-4ca0-a1d6-2a44ab38d983"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsm')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751d4d60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76870af0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-17f95ee1-2bc5-4c21-8b29-d97...nvocation-id': b'554e5459-ce7d-4085-b9f8-8465aa370913', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751d4d60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff751d4d60>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76870af0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-17f95ee1-2bc5-4c21-8b29-d97...nvocation-id': b'554e5459-ce7d-4085-b9f8-8465aa370913', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-17f95ee1-2bc5-4c21-8b29-d97171a7edf1"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_url[('pyxlsb', '.xlsb')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e79aec0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e1290c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-889c498e-6f64-4470-97e7-a80...nvocation-id': b'80d69c5d-093f-4adc-8acc-bfb8317b45ae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e79aec0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e79aec0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e1290c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-889c498e-6f64-4470-97e7-a80...nvocation-id': b'80d69c5d-093f-4adc-8acc-bfb8317b45ae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-889c498e-6f64-4470-97e7-a80ee0d82053"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[('odf', '.ods')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e7e1cf0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6c59b2b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-86723362-9b73-4462-9192-6de...nvocation-id': b'932a213f-4371-4f9f-8f01-91426669862d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e7e1cf0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e7e1cf0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6c59b2b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-86723362-9b73-4462-9192-6de...nvocation-id': b'932a213f-4371-4f9f-8f01-91426669862d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-86723362-9b73-4462-9192-6deb33bcfbeb"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('xlrd', '.xls')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557ee60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff7543c220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e8f85f9a-62c9-415b-bf92-336...nvocation-id': b'f298e7d5-fca3-4401-ba5c-79d490029c04', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557ee60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff7557ee60>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff7543c220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e8f85f9a-62c9-415b-bf92-336...nvocation-id': b'f298e7d5-fca3-4401-ba5c-79d490029c04', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e8f85f9a-62c9-415b-bf92-336596bf8a00"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsx')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dd6a6b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff751d4640>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4219e38e-1505-4252-a3f2-f82...nvocation-id': b'657206a6-e4a3-4599-8588-96330179e52f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dd6a6b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dd6a6b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff751d4640>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4219e38e-1505-4252-a3f2-f82...nvocation-id': b'657206a6-e4a3-4599-8588-96330179e52f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-4219e38e-1505-4252-a3f2-f82710fdafaa"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsm')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d68f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6c4e2020>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6ae48ad4-c435-4ddb-a272-d04...nvocation-id': b'bfdbee45-bd45-44c6-aa9c-68fcd7e5d3a9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d68f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f2d68f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6c4e2020>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6ae48ad4-c435-4ddb-a272-d04...nvocation-id': b'bfdbee45-bd45-44c6-aa9c-68fcd7e5d3a9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6ae48ad4-c435-4ddb-a272-d040aac09fec"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xls')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f4ef490>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-23dcc199-23ef-4baf-b825-8c2...nvocation-id': b'5fd93176-35fe-4688-9336-d1ea9381f2e8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f3201c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f4ef490>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-23dcc199-23ef-4baf-b825-8c2...nvocation-id': b'5fd93176-35fe-4688-9336-d1ea9381f2e8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-23dcc199-23ef-4baf-b825-8c2538f786ab"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsx')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76289bd0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff75fcb1f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9ef40223-4dc1-4c01-9bda-80f...nvocation-id': b'4365bc2c-e740-486c-85d9-a18a90b13e79', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76289bd0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76289bd0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff75fcb1f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9ef40223-4dc1-4c01-9bda-80f...nvocation-id': b'4365bc2c-e740-486c-85d9-a18a90b13e79', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9ef40223-4dc1-4c01-9bda-80f378177020"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsm')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f45a140>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76512110>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9eeab65d-eb3e-4cbb-9c12-242...nvocation-id': b'aa410cb0-6b28-4e3e-8cd2-b0659abb26fd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f45a140>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f45a140>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76512110>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9eeab65d-eb3e-4cbb-9c12-242...nvocation-id': b'aa410cb0-6b28-4e3e-8cd2-b0659abb26fd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9eeab65d-eb3e-4cbb-9c12-24231b663802"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('pyxlsb', '.xlsb')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e742200>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6dc242b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-abedf204-ec0d-412b-9de2-9e4...nvocation-id': b'9304411c-6d77-4a12-8f20-f27748ae41dd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e742200>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6e742200>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6dc242b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-abedf204-ec0d-412b-9de2-9e4...nvocation-id': b'9304411c-6d77-4a12-8f20-f27748ae41dd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-abedf204-ec0d-412b-9de2-9e455c4cb766"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('odf', '.ods')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76f43520>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff7611b3a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c4ca8abf-997a-4ec6-8331-964...nvocation-id': b'a7e85f42-962c-4542-b446-6da0ad2504b5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76f43520>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76f43520>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/home/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff7611b3a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c4ca8abf-997a-4ec6-8331-964...nvocation-id': b'a7e85f42-962c-4542-b446-6da0ad2504b5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c4ca8abf-997a-4ec6-8331-964168ce7ac8"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________________ ERROR at setup of test_styler_to_s3 ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dc98640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e79a650>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9f2275d6-e116-41a2-99ed-a70...nvocation-id': b'904ffd24-84e8-4fc2-aff4-8db41035bdc2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dc98640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6dc98640>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e79a650>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9f2275d6-e116-41a2-99ed-a70...nvocation-id': b'904ffd24-84e8-4fc2-aff4-8db41035bdc2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9f2275d6-e116-41a2-99ed-a70185a0f8a0"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[None] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751eb850>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff75112050>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0a83f724-7114-4463-a9c2-7a3...nvocation-id': b'fc116c15-399c-4b1a-ae37-e6c979dcedb1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff751eb850>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff751eb850>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff75112050>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0a83f724-7114-4463-a9c2-7a3...nvocation-id': b'fc116c15-399c-4b1a-ae37-e6c979dcedb1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0a83f724-7114-4463-a9c2-7a38d4735854"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[gzip] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edcfdc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff2edbbaf0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b580c2d6-de98-49b1-8179-f72...nvocation-id': b'663895f6-73ed-487e-b1bd-e38c2c72750e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edcfdc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edcfdc0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff2edbbaf0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b580c2d6-de98-49b1-8179-f72...nvocation-id': b'663895f6-73ed-487e-b1bd-e38c2c72750e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-b580c2d6-de98-49b1-8179-f727e94e40f0"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[bz2] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7553ae00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6dca4130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c61a48cb-8521-4034-bcbc-b62...nvocation-id': b'62c15526-95b5-46f4-a35b-20bfdcb3e181', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff7553ae00>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff7553ae00>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6dca4130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c61a48cb-8521-4034-bcbc-b62...nvocation-id': b'62c15526-95b5-46f4-a35b-20bfdcb3e181', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c61a48cb-8521-4034-bcbc-b62189e5ea44"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zip] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76314e80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff2eacf910>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e19436e5-de54-4a79-bb1f-670...nvocation-id': b'0da30f9c-1628-4614-8b1e-7bb970f4ba6b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff76314e80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff76314e80>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff2eacf910>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e19436e5-de54-4a79-bb1f-670...nvocation-id': b'0da30f9c-1628-4614-8b1e-7bb970f4ba6b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e19436e5-de54-4a79-bb1f-6705f2113e59"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________________ ERROR at setup of test_with_s3_url[xz] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff754181f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff64591300>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9626e95f-f76e-4d8f-80e7-fdf...nvocation-id': b'0c9bb20e-3167-4ee1-b83a-250ea9641aa6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff754181f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff754181f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff64591300>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9626e95f-f76e-4d8f-80e7-fdf...nvocation-id': b'0c9bb20e-3167-4ee1-b83a-250ea9641aa6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9626e95f-f76e-4d8f-80e7-fdf69ff85f04"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[tar] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edf70d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff76af9510>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3792872f-4c99-48a1-b8c6-6ff...nvocation-id': b'd9a3c88f-bedd-42e2-81d7-c8487bc50dde', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edf70d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edf70d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff76af9510>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3792872f-4c99-48a1-b8c6-6ff...nvocation-id': b'd9a3c88f-bedd-42e2-81d7-c8487bc50dde', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3792872f-4c99-48a1-b8c6-6ff159596997"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zstd] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edbfeb0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e741b10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-87872a85-4bb1-49ba-9065-c03...nvocation-id': b'b9963247-af6d-433d-887d-3f9e56679eef', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edbfeb0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff2edbfeb0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e741b10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-87872a85-4bb1-49ba-9065-c03...nvocation-id': b'b9963247-af6d-433d-887d-3f9e56679eef', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-87872a85-4bb1-49ba-9065-c038b4315af1"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestPandasContainer.test_read_s3_jsonl ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f39f4f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3ab220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3527c231-6aed-4c8b-b75c-941...nvocation-id': b'356591f5-acc8-46cd-bad5-8573a10977bd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f39f4f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff6f39f4f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f3ab220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3527c231-6aed-4c8b-b75c-941...nvocation-id': b'356591f5-acc8-46cd-bad5-8573a10977bd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3527c231-6aed-4c8b-b75c-9418a3107f82"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_______________ ERROR at setup of TestPandasContainer.test_to_s3 _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fe500>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6e7e3d30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-635df299-a09f-4d67-913f-b86...nvocation-id': b'1d2339b5-f446-41fb-b603-3c51a6cab43f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fe500>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff762fe500>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6e7e3d30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-635df299-a09f-4d67-913f-b86...nvocation-id': b'1d2339b5-f446-41fb-b603-3c51a6cab43f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-635df299-a09f-4d67-913f-b8614c746b80"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[lxml] _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2f00f0d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff6f49b310>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b4fd6062-f9c7-4381-8c5a-57b...nvocation-id': b'bbfa7e67-cbbf-492f-981b-06b531b13255', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff2f00f0d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff2f00f0d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff6f49b310>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b4fd6062-f9c7-4381-8c5a-57b...nvocation-id': b'bbfa7e67-cbbf-492f-981b-06b531b13255', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-b4fd6062-f9c7-4381-8c5a-57b20924cb91"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[etree] ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3280>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0xffff2eac9690>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0b592753-518d-437a-ad3b-bd3...nvocation-id': b'7ef171a8-9ac0-40ea-b952-4589428aced5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3280>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0xffff761f3280>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0xffff2eac9690>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0b592753-518d-437a-ad3b-bd3...nvocation-id': b'7ef171a8-9ac0-40ea-b952-4589428aced5', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0b592753-518d-437a-ad3b-bd383cf06678"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
=================================== FAILURES ===================================
_________________ test_dataframe_to_sql[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0xffff771a3a90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff771a3dc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff771a3a90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff771a3a90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_dataframe_to_sql[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0xffff762ef4c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff762ee440>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff762ef4c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff762ef4c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_dataframe_to_sql[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0xffff765b6560>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_dataframe_to_sql[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0xffff762cdab0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine] ___________

self = <pymysql.connections.Connection object at 0xffff76d1b9a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76d1ba60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76d1b9a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76d1b9a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn] ____________

self = <pymysql.connections.Connection object at 0xffff76029e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76029c60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76029e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76029e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine] ________

self = <sqlalchemy.engine.base.Connection object at 0xffff75f81960>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn] _________

self = <sqlalchemy.engine.base.Connection object at 0xffff766d56f0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0xffff76f66cb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76f677f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76f66cb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76f66cb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0xffff76081cf0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff760819c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76081cf0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76081cf0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff7685f0d0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0xffff76341a20>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0xffff7645c7c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7645c6a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7645c7c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7645c7c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0xffff76062140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76062170>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76062140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76062140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff75fa21a0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0xffff76dacd90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0xffff768ee920>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff768ecd60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff768ee920>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff768ee920>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0xffff75fca590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75fca8f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75fca590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75fca590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff76041b10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0xffff76060430>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0xffff76269270>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff762686d0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76269270>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76269270>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0xffff75421d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75421db0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75421d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75421d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff75419cf0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0xffff76371c90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0xffff761f7fa0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff761f4f10>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff761f7fa0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff761f7fa0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0xffff75542b00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75542a70>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75542b00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75542b00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff76e16140>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0xffff768482b0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0xffff7685d6c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7685c2e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7685d6c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7685d6c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0xffff75561a50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75561cc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75561a50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75561a50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff754a39d0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0xffff766d7a60>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ test_to_sql[None-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0xffff75418ee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7541bd90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75418ee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75418ee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_____________________ test_to_sql[None-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0xffff76df0760>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76df1ea0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76df0760>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76df0760>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________________ test_to_sql[None-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0xffff75602440>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql[None-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0xffff761a2890>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ test_to_sql[multi-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0xffff7696eb90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7696ee30>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7696eb90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7696eb90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________________ test_to_sql[multi-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0xffff7673c400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7673df00>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7673c400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff7673c400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql[multi-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0xffff761a3b50>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql[multi-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0xffff762a1cf0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_to_sql_exist[replace-1-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0xffff766d7bb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff766d7370>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff766d7bb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff766d7bb0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_exist[replace-1-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0xffff760729e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff760733a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760729e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760729e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________ test_to_sql_exist[replace-1-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0xffff755b66e0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________ test_to_sql_exist[replace-1-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0xffff76c4d090>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist[append-2-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0xffff763726e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff763715d0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff763726e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff763726e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql_exist[append-2-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0xffff767adc90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff767aff70>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff767adc90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff767adc90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_to_sql_exist[append-2-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0xffff76041b10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_to_sql_exist[append-2-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0xffff764dc7f0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql_exist_fail[mysql_pymysql_engine] _________________

self = <pymysql.connections.Connection object at 0xffff75538370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff7553ad10>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75538370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75538370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_to_sql_exist_fail[mysql_pymysql_conn] __________________

self = <pymysql.connections.Connection object at 0xffff755cac20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff755cad70>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff755cac20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff755cac20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_to_sql_exist_fail[postgresql_psycopg2_engine] ______________

self = <sqlalchemy.engine.base.Connection object at 0xffff765a1cf0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist_fail[postgresql_psycopg2_conn] _______________

self = <sqlalchemy.engine.base.Connection object at 0xffff76c738b0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_query[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0xffff76c221a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76c23460>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76c221a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76c221a0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_query[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0xffff75341e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75341f60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75341e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75341e40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_query[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0xffff76515060>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_query[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0xffff753a5420>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_query_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0xffff763f6fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff763f65c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff763f6fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff763f6fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_query_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0xffff75f80df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75f83ee0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75f80df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75f80df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_query_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0xffff754fbfa0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_query_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0xffff753b45b0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_expression_with_parameter[mysql_pymysql_engine] _____

self = <pymysql.connections.Connection object at 0xffff76c23f10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76c20220>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76c23f10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76c23f10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______ test_read_iris_query_expression_with_parameter[mysql_pymysql_conn] ______

self = <pymysql.connections.Connection object at 0xffff75323280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75323400>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75323280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75323280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine] __

self = <sqlalchemy.engine.base.Connection object at 0xffff75538070>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn] ___

self = <sqlalchemy.engine.base.Connection object at 0xffff7702ce80>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______ test_read_iris_query_string_with_parameter[mysql_pymysql_engine] _______

self = <pymysql.connections.Connection object at 0xffff764a4a60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff764a72e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff764a4a60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff764a4a60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_read_iris_query_string_with_parameter[mysql_pymysql_conn] ________

self = <pymysql.connections.Connection object at 0xffff75342ce0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75342c20>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75342ce0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75342ce0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0xffff761f1f60>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0xffff76072800>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_table[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0xffff765147c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76516530>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff765147c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff765147c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_table[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0xffff766e14b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff766e0ac0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff766e14b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff766e14b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_table[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0xffff75320460>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_table[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0xffff76316620>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_table_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0xffff751bca90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff751bcd60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff751bca90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff751bca90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_table_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0xffff751a3370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff751a33a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff751a3370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff751a3370>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_table_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0xffff762ef250>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_table_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0xffff76bebd00>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql_callable[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0xffff760cff10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff760cdf90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760cff10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760cff10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_to_sql_callable[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0xffff76848670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff76849b10>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76848670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff76848670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_callable[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0xffff754a20e0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_to_sql_callable[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0xffff766e09a0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_default_type_conversion[mysql_pymysql_engine] ______________

self = <pymysql.connections.Connection object at 0xffff765162c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff765169b0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff765162c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff765162c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_default_type_conversion[mysql_pymysql_conn] _______________

self = <pymysql.connections.Connection object at 0xffff75512fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75511780>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75512fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75512fe0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_read_procedure[mysql_pymysql_engine] ___________________

self = <pymysql.connections.Connection object at 0xffff75323b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff75320d90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75323b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff75323b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_procedure[mysql_pymysql_conn] ____________________

self = <pymysql.connections.Connection object at 0xffff764ad630>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff764ae170>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff764ad630>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff764ad630>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0xffff7544a560>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0xffff76787550>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0xffff760f6b30>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0xffff7702f370>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine] ___

self = <sqlalchemy.engine.base.Connection object at 0xffff762ac040>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn] ____

self = <sqlalchemy.engine.base.Connection object at 0xffff75f8aa10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________ test_insertion_method_on_conflict_update[mysql_pymysql_engine] ________

self = <pymysql.connections.Connection object at 0xffff760a1a20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff760a2f50>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760a1a20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff760a1a20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________ test_insertion_method_on_conflict_update[mysql_pymysql_conn] _________

self = <pymysql.connections.Connection object at 0xffff74fd1fc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               OSError: [Errno 99] Cannot assign requested address

/usr/local/lib/python3.10/socket.py:833: OSError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0xffff74fd1e40>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff74fd1fc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0xffff74fd1fc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 99] Cannot assign requested address)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________________ TestS3.test_read_s3_fails ___________________________

self = <aiohttp.connector.TCPConnector object at 0xffff75488340>
req = <aiohttp.client_reqrep.ClientRequest object at 0xffff7657bdf0>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
>               return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/asyncio/base_events.py:1067: in create_connection
    raise exceptions[0]
/usr/local/lib/python3.10/asyncio/base_events.py:1052: in create_connection
    sock = await self._connect_sock(
/usr/local/lib/python3.10/asyncio/base_events.py:963: in _connect_sock
    await self.sock_connect(sock, address)
/usr/local/lib/python3.10/asyncio/selector_events.py:500: in sock_connect
    return await fut
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=True closed=False debug=False>
fut = <Future finished exception=ConnectionRefusedError(111, "Connect call failed ('127.0.0.1', 5555)")>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
address = ('127.0.0.1', 5555)

    def _sock_connect_cb(self, fut, sock, address):
        if fut.done():
            return
    
        try:
            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
            if err != 0:
                # Jump to any except clause below.
>               raise OSError(err, f'Connect call failed {address}')
E               ConnectionRefusedError: [Errno 111] Connect call failed ('127.0.0.1', 5555)

/usr/local/lib/python3.10/asyncio/selector_events.py:535: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <aiobotocore.httpsession.AIOHTTPSession object at 0xffff6f30eb00>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...a96c5941f3', 'amz-sdk-invocation-id': b'081b17e5-dd5c-4959-a401-749d72b36e23', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
>           response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/aiohttp/client.py:536: in _request
    conn = await self._connector.connect(
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:540: in connect
    proto = await self._create_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:901: in _create_connection
    _, proto = await self._create_direct_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1206: in _create_direct_connection
    raise last_exc
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1175: in _create_direct_connection
    transp, proto = await self._wrap_create_connection(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiohttp.connector.TCPConnector object at 0xffff75488340>
req = <aiohttp.client_reqrep.ClientRequest object at 0xffff7657bdf0>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
                return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa
        except cert_errors as exc:
            raise ClientConnectorCertificateError(req.connection_key, exc) from exc
        except ssl_errors as exc:
            raise ClientConnectorSSLError(req.connection_key, exc) from exc
        except OSError as exc:
            if exc.errno is None and isinstance(exc, asyncio.TimeoutError):
                raise
>           raise client_error(req.connection_key, exc) from exc
E           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 127.0.0.1:5555 ssl:default [Connect call failed ('127.0.0.1', 5555)]

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:988: ClientConnectorError

During handling of the above exception, another exception occurred:

self = <pandas.tests.io.parser.test_network.TestS3 object at 0xffff794b5480>
s3so = {'client_kwargs': {'endpoint_url': 'http://127.0.0.1:5555/'}}

    def test_read_s3_fails(self, s3so):
        msg = "The specified bucket does not exist"
        with pytest.raises(OSError, match=msg):
>           read_csv("s3://nyqpug/asdf.csv", storage_options=s3so)

pandas/tests/io/parser/test_network.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/io/parsers/readers.py:945: in read_csv
    return _read(filepath_or_buffer, kwds)
pandas/io/parsers/readers.py:608: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
pandas/io/parsers/readers.py:1444: in __init__
    self._engine = self._make_engine(f, self.engine)
pandas/io/parsers/readers.py:1701: in _make_engine
    self.handles = get_handle(
pandas/io/common.py:714: in get_handle
    ioargs = _get_filepath_or_buffer(
pandas/io/common.py:416: in _get_filepath_or_buffer
    ).open()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:134: in open
    return self.__enter__()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:102: in __enter__
    f = self.fs.open(self.path, mode=mode)
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1241: in open
    f = self._open(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:659: in _open
    return S3File(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:2066: in __init__
    super().__init__(
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1597: in __init__
    self.size = self.details["size"]
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1610: in details
    self._details = self.fs.info(self.path)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:121: in wrapper
    return sync(self.loop, func, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:106: in sync
    raise return_result
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:61: in _runner
    result[0] = await coro
/usr/local/lib/python3.10/site-packages/s3fs/core.py:1271: in _info
    out = await self._call_s3(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:348: in _call_s3
    return await _error_wrapper(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:140: in _error_wrapper
    raise err
/usr/local/lib/python3.10/site-packages/s3fs/core.py:113: in _error_wrapper
    return await func(*args, **kwargs)
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:361: in _make_api_call
    http, parsed_response = await self._make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:386: in _make_request
    return await self._endpoint.make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:100: in _send_request
    while await self._needs_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:262: in _needs_retry
    responses = await self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/aiobotocore/hooks.py:66: in _emit
    response = await resolve_awaitable(handler(**kwargs))
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:107: in _call
    if await resolve_awaitable(self._checker(**checker_kwargs)):
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:126: in _call
    should_retry = await self._should_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:165: in _should_retry
    return await resolve_awaitable(
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:174: in _call
    checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:181: in _do_get_response
    http_response = await self._send(request)
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:285: in _send
    return await self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiobotocore.httpsession.AIOHTTPSession object at 0xffff6f30eb00>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...a96c5941f3', 'amz-sdk-invocation-id': b'081b17e5-dd5c-4959-a401-749d72b36e23', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
            response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )
    
            http_response = aiobotocore.awsrequest.AioAWSResponse(
                str(response.url), response.status, response.headers, response
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                await http_response.content
    
            return http_response
        except ClientSSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (ClientProxyConnectionError, ClientHttpProxyError) as e:
            raise ProxyConnectionError(
                proxy_url=mask_proxy_url(proxy_url), error=e
            )
        except (
            ServerDisconnectedError,
            aiohttp.ClientPayloadError,
            aiohttp.http_exceptions.BadStatusLine,
        ) as e:
            raise ConnectionClosedError(
                error=e, request=request, endpoint_url=request.url
            )
        except ServerTimeoutError as e:
            if str(e).lower().startswith('connect'):
                raise ConnectTimeoutError(endpoint_url=request.url, error=e)
            else:
                raise ReadTimeoutError(endpoint_url=request.url, error=e)
        except (
            ClientConnectorError,
            ClientConnectionError,
            socket.gaierror,
        ) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/nyqpug/asdf.csv"

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:253: EndpointConnectionError
---------------- generated xml file: /home/pandas/test-data.xml ----------------
============================= slowest 30 durations =============================
20.52s call     pandas/tests/io/parser/test_network.py::TestS3::test_write_s3_csv_fails
14.82s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket
13.76s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('xlrd', '.xls')]
12.30s setup    pandas/tests/io/excel/test_style.py::test_styler_to_s3
12.14s call     pandas/tests/io/parser/test_network.py::TestS3::test_write_s3_parquet_fails
12.12s setup    pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col1]
11.82s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('pyxlsb', '.xlsb')]
10.72s setup    pandas/tests/io/json/test_compression.py::test_with_s3_url[tar]
10.67s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsx')]
10.28s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsm')]
9.93s setup    pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[etree]
9.89s setup    pandas/tests/io/test_fsspec.py::test_s3_protocols[s3n]
9.73s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsx')]
9.32s setup    pandas/tests/io/test_parquet.py::TestParquetFastParquet::test_s3_roundtrip
9.28s setup    pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_explicit_fs
9.21s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_handles_boto_s3_object
9.18s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xls')]
9.11s setup    pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col0]
8.99s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_feather_s3_file_path
8.93s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsm')]
8.77s setup    pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip
8.59s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_with_hash_in_key
8.47s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsx')]
8.42s setup    pandas/tests/io/test_fsspec.py::test_s3_parquet
8.08s setup    pandas/tests/io/test_fsspec.py::test_s3_protocols[s3]
7.90s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked
7.70s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('xlrd', '.xls')]
7.69s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsm')]
7.04s setup    pandas/tests/io/json/test_compression.py::test_with_s3_url[zip]
6.95s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xls')]
=========================== short test summary info ============================
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_engine] - ...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_conn] - sq...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_conn] - s...
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_conn]
FAILED pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails - b...
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_private_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3n_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3a_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_infer_s3_compression
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails_private
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_handles_boto_s3_object
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_chunked_download
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_with_hash_in_key
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_feather_s3_file_path
ERROR pandas/tests/io/test_fsspec.py::test_from_s3_csv - botocore.exceptions....
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3] - botocore.except...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3a] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3n] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_parquet - botocore.exceptions.E...
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_explicit_fs
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col0]
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col1]
ERROR pandas/tests/io/test_parquet.py::TestParquetFastParquet::test_s3_roundtrip
ERROR pandas/tests/io/test_s3.py::test_read_without_creds_from_pub_bucket - b...
ERROR pandas/tests/io/test_s3.py::test_read_with_creds_from_pub_bucket - boto...
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_style.py::test_styler_to_s3 - botocore.excep...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[None] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[gzip] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[bz2] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zip] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[xz] - botoco...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[tar] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zstd] - boto...
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_read_s3_jsonl
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_to_s3 - ...
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[lxml] - b...
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[etree] - ...
= 93 failed, 2066 passed, 177 skipped, 52 xfailed, 55 errors in 516.38s (0:08:36) =
