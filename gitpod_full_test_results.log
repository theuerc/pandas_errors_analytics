[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.0, pluggy-1.2.0
rootdir: /workspace/pandas
configfile: pyproject.toml
plugins: typeguard-3.0.2, anyio-3.7.0, hypothesis-6.80.0, asyncio-0.21.0, cov-4.1.0, cython-0.2.1, localserver-0.7.1, xdist-3.3.1
asyncio: mode=strict
collected 2443 items

pandas/tests/io/test_sql.py FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF...FFFF....FFFF...FFFF...FFFF...FFFFFFFFFFFF.................................................................................................................................ss..............x.....................................................ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.......................
pandas/tests/io/parser/test_network.py ................ssss.....EEEEEEEEEEFExxEEEE
pandas/tests/io/test_fsspec.py ............EEEEEs............
pandas/tests/io/test_parquet.py ......................................x......................EEEE..............xxxxxx...............E......................
pandas/tests/io/test_s3.py .EE
pandas/tests/io/excel/test_readers.py ..............................x.......x.....................................xxxxxx............................x.......x...............................................................................x.......x.......x.................................s..s..s.s..s..s.s..s..s.s..s..s.s..s..s.........................ssssssssssssss...................................................xx.xxx.......x.........................................................................................EEEEEEEEEEEEEEEE......................................x.......x.............xx................................x.......x.......................................................................................................................xs......xs..............................................................x.......x.......................................................................................................................x...............xs...sss..
pandas/tests/io/excel/test_style.py ...................................................................................................................................E
pandas/tests/io/json/test_compression.py ........EEEEEEE...............................................
pandas/tests/io/json/test_pandas.py ...........................................................................................................xxxx................................xxx.................................................................................................................................................................E........x................................................................xx.............E.....x...........................................
pandas/tests/io/xml/test_to_xml.py ......................................................................s...............................................................EE

==================================== ERRORS ====================================
_____________ ERROR at setup of TestS3.test_parse_public_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8be73d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6dff190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9afea355-9ae3-4794-901e-385...nvocation-id': b'338cc026-44c5-425c-879c-19008fc46daa', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8be73d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8be73d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6dff190>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9afea355-9ae3-4794-901e-385...nvocation-id': b'338cc026-44c5-425c-879c-19008fc46daa', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9afea355-9ae3-4794-901e-3856f46d4e6f"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_private_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9495000>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6d36020>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-e96fb8de-3984-4c91-b5d8-f02...nvocation-id': b'0863538f-e6fe-433f-8748-b4d980a2b1f3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9495000>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9495000>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6d36020>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-e96fb8de-3984-4c91-b5d8-f02...nvocation-id': b'0863538f-e6fe-433f-8748-b4d980a2b1f3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-e96fb8de-3984-4c91-b5d8-f021b5cae7ca"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3n_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5ffa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8b283d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-15439d96-ec1a-46b3-b40f-00c...nvocation-id': b'21c33ff6-30ab-4213-adb1-ff640403c438', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5ffa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5ffa0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8b283d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-15439d96-ec1a-46b3-b40f-00c...nvocation-id': b'21c33ff6-30ab-4213-adb1-ff640403c438', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-15439d96-ec1a-46b3-b40f-00c838a75fbb"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3a_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8a04ac0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8648b20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8ae65fa0-8fea-4f6c-9c53-254...nvocation-id': b'88dd6818-03af-403e-944f-72a3bc1a4a2c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8a04ac0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8a04ac0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8648b20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8ae65fa0-8fea-4f6c-9c53-254...nvocation-id': b'88dd6818-03af-403e-944f-72a3bc1a4a2c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-8ae65fa0-8fea-4f6c-9c53-254d2c1d92d3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef49bb670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6cbc8b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2b1cfe79-f2f8-498a-b37b-8e1...nvocation-id': b'e0a5fec3-342a-4db5-a97d-1658917f3d9e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef49bb670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef49bb670>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6cbc8b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2b1cfe79-f2f8-498a-b37b-8e1...nvocation-id': b'e0a5fec3-342a-4db5-a97d-1658917f3d9e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-2b1cfe79-f2f8-498a-b37b-8e1a9d54c1c9"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef96e6aa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bfff70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3614edd0-f7bb-4ce1-9a6d-26b...nvocation-id': b'1f0b6a98-243c-41c9-a5d6-c789ca45ae3b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef96e6aa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef96e6aa0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bfff70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3614edd0-f7bb-4ce1-9a6d-26b...nvocation-id': b'1f0b6a98-243c-41c9-a5d6-c789ca45ae3b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3614edd0-f7bb-4ce1-9a6d-26b0b7a8e7be"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked_python ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9226fe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6d35060>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-07465c85-7336-4005-85f7-d62...nvocation-id': b'3b9fe6fd-a565-4b3e-bc45-cf72095dda9a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9226fe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9226fe0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6d35060>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-07465c85-7336-4005-85f7-d62...nvocation-id': b'3b9fe6fd-a565-4b3e-bc45-cf72095dda9a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-07465c85-7336-4005-85f7-d6221beec1a9"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_python __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef85dee30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef9181a50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d615b363-1659-470a-bb24-7cc...nvocation-id': b'ec55cc3d-c0c1-47b0-84aa-bcb64e6b0332', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef85dee30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef85dee30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef9181a50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d615b363-1659-470a-bb24-7cc...nvocation-id': b'ec55cc3d-c0c1-47b0-84aa-bcb64e6b0332', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d615b363-1659-470a-bb24-7ccc3bac14dc"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of TestS3.test_infer_s3_compression ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5f8b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef49d8eb0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6af9277f-41f9-4d3e-8ffc-369...nvocation-id': b'b4f6724d-30b4-4d01-bf19-09a30899ee2d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5f8b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8f5f8b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef49d8eb0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6af9277f-41f9-4d3e-8ffc-369...nvocation-id': b'b4f6724d-30b4-4d01-bf19-09a30899ee2d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6af9277f-41f9-4d3e-8ffc-3695ebb5e63b"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows_python _______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef93950f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef96b9870>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3bff03f8-f695-469f-89c8-078...nvocation-id': b'b6eb8418-fc9d-4362-acf1-28aa59015c2b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef93950f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef93950f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef96b9870>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3bff03f8-f695-469f-89c8-078...nvocation-id': b'b6eb8418-fc9d-4362-acf1-28aa59015c2b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3bff03f8-f695-469f-89c8-078620506a91"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________ ERROR at setup of TestS3.test_read_s3_fails_private ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeeffa95a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe91720>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-093b4bb0-cc6b-4a95-9221-ae5...nvocation-id': b'a81a3c19-3ef3-4458-83ac-213f75552130', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeeffa95a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeeffa95a0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe91720>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-093b4bb0-cc6b-4a95-9221-ae5...nvocation-id': b'a81a3c19-3ef3-4458-83ac-213f75552130', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-093b4bb0-cc6b-4a95-9221-ae511d93664c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
________ ERROR at setup of TestS3.test_read_csv_handles_boto_s3_object _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef45a8610>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9029e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6b3208c3-2dd4-477b-ba41-d6c...nvocation-id': b'f66dd0dd-9d52-4be8-8f53-cce50ef69244', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef45a8610>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef45a8610>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9029e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6b3208c3-2dd4-477b-ba41-d6c...nvocation-id': b'f66dd0dd-9d52-4be8-8f53-cce50ef69244', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6b3208c3-2dd4-477b-ba41-d6c2a54d76a1"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_csv_chunked_download ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8ab9ae0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bfee00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-88987991-fb8e-4729-a9e0-937...nvocation-id': b'52069d11-4a19-47a8-b0d1-e7350b2bcaca', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8ab9ae0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8ab9ae0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bfee00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-88987991-fb8e-4729-a9e0-937...nvocation-id': b'52069d11-4a19-47a8-b0d1-e7350b2bcaca', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-88987991-fb8e-4729-a9e0-937055c12369"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_read_s3_with_hash_in_key ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1e6e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4ab1570>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3cb3b9a6-c65e-4536-ad56-a5a...nvocation-id': b'57b52679-8b08-4e79-a144-5343f26ffddd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1e6e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1e6e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4ab1570>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3cb3b9a6-c65e-4536-ad56-a5a...nvocation-id': b'57b52679-8b08-4e79-a144-5343f26ffddd', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3cb3b9a6-c65e-4536-ad56-a5a60145a307"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_feather_s3_file_path ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9510ca0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef88341c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c052d708-2443-4592-96cf-d69...nvocation-id': b'ae3c61d4-e5c7-41b9-aa59-d4d5e07276dc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9510ca0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef9510ca0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef88341c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c052d708-2443-4592-96cf-d69...nvocation-id': b'ae3c61d4-e5c7-41b9-aa59-d4d5e07276dc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c052d708-2443-4592-96cf-d69cb3ee274a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________________ ERROR at setup of test_from_s3_csv ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6cba8f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe90460>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1e75eb22-4a33-4fcf-b153-378...nvocation-id': b'61429561-cd6e-4d20-b31c-9cb10c3015de', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6cba8f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6cba8f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe90460>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1e75eb22-4a33-4fcf-b153-378...nvocation-id': b'61429561-cd6e-4d20-b31c-9cb10c3015de', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1e75eb22-4a33-4fcf-b153-37874fb7b935"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6e63430>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8987280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-19031c26-0cf8-4146-99a1-93e...nvocation-id': b'3f21fb68-0398-4945-b35a-d18a862c0ac1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6e63430>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6e63430>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8987280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-19031c26-0cf8-4146-99a1-93e...nvocation-id': b'3f21fb68-0398-4945-b35a-d18a862c0ac1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-19031c26-0cf8-4146-99a1-93e8310fae1c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3a] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b4d930>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef85974c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ddd042a2-a3ba-4fb0-a8d0-029...nvocation-id': b'e915413a-b451-4394-92fe-859b8e7daf63', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b4d930>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b4d930>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef85974c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ddd042a2-a3ba-4fb0-a8d0-029...nvocation-id': b'e915413a-b451-4394-92fe-859b8e7daf63', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ddd042a2-a3ba-4fb0-a8d0-0299acef7071"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3n] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6c13b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8c4a350>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aaac63f8-7f63-4290-820f-2fd...nvocation-id': b'2d57a773-5d86-4faf-9eea-d472f0961b37', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6c13b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6c13b20>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8c4a350>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aaac63f8-7f63-4290-820f-2fd...nvocation-id': b'2d57a773-5d86-4faf-9eea-d472f0961b37', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-aaac63f8-7f63-4290-820f-2fd5d895ded3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________________ ERROR at setup of test_s3_parquet _______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefffe530>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8b5d0f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fbf66ae9-c356-4cea-a1b5-304...nvocation-id': b'55d8e836-180b-457a-9974-0ad5c9bd80d6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefffe530>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefffe530>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8b5d0f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fbf66ae9-c356-4cea-a1b5-304...nvocation-id': b'55d8e836-180b-457a-9974-0ad5c9bd80d6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-fbf66ae9-c356-4cea-a1b5-304e8d45f3cb"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_explicit_fs ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8e7a5f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe93070>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e11ad812-2568-4d1e-ab97-d2c...nvocation-id': b'de3452c1-a9de-4ddf-b8a6-1641e8e9372f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8e7a5f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8e7a5f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeefe93070>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e11ad812-2568-4d1e-ab97-d2c...nvocation-id': b'de3452c1-a9de-4ddf-b8a6-1641e8e9372f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e11ad812-2568-4d1e-ab97-d2cefef4430a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92e52d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4471a20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0186886b-ad27-4e7c-a281-a45...nvocation-id': b'01a88fb2-7acc-4d67-b933-8130df3e2b24', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92e52d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92e52d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4471a20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0186886b-ad27-4e7c-a281-a45...nvocation-id': b'01a88fb2-7acc-4d67-b933-8130df3e2b24', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0186886b-ad27-4e7c-a281-a45f37fc569a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col0] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef8964d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeeffbca30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6a35a155-a67f-4c54-91fd-72e...nvocation-id': b'8cf127dd-1009-493f-8568-aa5e661721df', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef8964d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef8964d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeeffbca30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6a35a155-a67f-4c54-91fd-72e...nvocation-id': b'8cf127dd-1009-493f-8568-aa5e661721df', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6a35a155-a67f-4c54-91fd-72eb6b30b513"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col1] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1c5e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4c31cc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0bdcb898-1299-4b7d-ac16-107...nvocation-id': b'6d2e82a1-8c5e-48ad-9637-8c79db826acb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1c5e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1c5e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4c31cc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0bdcb898-1299-4b7d-ac16-107...nvocation-id': b'6d2e82a1-8c5e-48ad-9637-8c79db826acb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0bdcb898-1299-4b7d-ac16-107ddad60ad2"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestParquetFastParquet.test_s3_roundtrip __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef46f1cc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4278280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1b592d50-369a-413f-9602-43e...nvocation-id': b'e131e8ad-3359-4c02-8ad6-4317007e427c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef46f1cc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef46f1cc0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4278280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1b592d50-369a-413f-9602-43e...nvocation-id': b'e131e8ad-3359-4c02-8ad6-4317007e427c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1b592d50-369a-413f-9602-43edb72d5e67"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of test_read_without_creds_from_pub_bucket ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe48640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef91fcac0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5e25c364-e20c-4670-a894-3fb...nvocation-id': b'f5143052-b144-443f-ae73-63162e485048', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe48640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe48640>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef91fcac0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-5e25c364-e20c-4670-a894-3fb...nvocation-id': b'f5143052-b144-443f-ae73-63162e485048', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-5e25c364-e20c-4670-a894-3fb49aae51ca"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of test_read_with_creds_from_pub_bucket ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8984e50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-92cf703e-0ffe-4139-bfaa-c73...nvocation-id': b'ba8ee637-4f5c-442d-92c9-60533540c240', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930670>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8984e50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-92cf703e-0ffe-4139-bfaa-c73...nvocation-id': b'ba8ee637-4f5c-442d-92c9-60533540c240', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-92cf703e-0ffe-4139-bfaa-c738511d87dd"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_url[('xlrd', '.xls')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6aa4df0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4c32200>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e9b55f1b-64fc-4fd8-8aa2-a43...nvocation-id': b'f5c06d65-dd0a-462f-a64e-9b38a789619d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6aa4df0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6aa4df0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4c32200>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e9b55f1b-64fc-4fd8-8aa2-a43...nvocation-id': b'f5c06d65-dd0a-462f-a64e-9b38a789619d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e9b55f1b-64fc-4fd8-8aa2-a4367836222e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsx')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef437280>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef85dc730>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f13a0c8d-3a7b-456b-a53c-62b...nvocation-id': b'579de1fd-7f30-4265-9934-7ead27a7c13c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef437280>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef437280>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef85dc730>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f13a0c8d-3a7b-456b-a53c-62b...nvocation-id': b'579de1fd-7f30-4265-9934-7ead27a7c13c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-f13a0c8d-3a7b-456b-a53c-62be6dad9e82"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsm')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef87d9c60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8834f70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d7cd62dd-c9e8-45cd-beeb-142...nvocation-id': b'9b7dfb7a-727a-4403-bb56-e8d561ad6f7c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef87d9c60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef87d9c60>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8834f70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d7cd62dd-c9e8-45cd-beeb-142...nvocation-id': b'9b7dfb7a-727a-4403-bb56-e8d561ad6f7c', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d7cd62dd-c9e8-45cd-beeb-1424a323efde"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xls')] ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab0820>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8716c20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa8a93f7-e2e7-462a-9936-17b...nvocation-id': b'3d642c16-726e-43fc-a372-234418b8c1b6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab0820>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab0820>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8716c20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa8a93f7-e2e7-462a-9936-17b...nvocation-id': b'3d642c16-726e-43fc-a372-234418b8c1b6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-aa8a93f7-e2e7-462a-9936-17bbc351f9cc"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsx')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92c5750>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef69dd420>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-110aada0-cd3a-462f-b34b-be7...nvocation-id': b'84e024bf-dd3c-4e55-b52c-81855902b9a6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92c5750>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef92c5750>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef69dd420>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-110aada0-cd3a-462f-b34b-be7...nvocation-id': b'84e024bf-dd3c-4e55-b52c-81855902b9a6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-110aada0-cd3a-462f-b34b-be7448e2eb7d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsm')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab2bc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeef380340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1081656b-edbb-445e-9612-d57...nvocation-id': b'ab9f3753-7f39-4472-a8d3-1a9ad03477d3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab2bc0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4ab2bc0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeef380340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1081656b-edbb-445e-9612-d57...nvocation-id': b'ab9f3753-7f39-4472-a8d3-1a9ad03477d3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1081656b-edbb-445e-9612-d57d2d76efc0"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_url[('pyxlsb', '.xlsb')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe924a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef45a9450>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c0f65cb7-8cfa-4241-9cb0-9f0...nvocation-id': b'3facde05-11c8-49b5-849b-d41eb67fec57', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe924a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe924a0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef45a9450>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c0f65cb7-8cfa-4241-9cb0-9f0...nvocation-id': b'3facde05-11c8-49b5-849b-d41eb67fec57', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c0f65cb7-8cfa-4241-9cb0-9f02bbfa0a61"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[('odf', '.ods')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930af0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef88cb130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa479c09-f89e-42e7-a596-8ba...nvocation-id': b'abcd8af7-cfd5-4678-bc8b-5b16d572cdee', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930af0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef930af0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef88cb130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa479c09-f89e-42e7-a596-8ba...nvocation-id': b'abcd8af7-cfd5-4678-bc8b-5b16d572cdee', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-aa479c09-f89e-42e7-a596-8ba2619f210a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('xlrd', '.xls')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bd3f70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faee6fcbd90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6a973feb-91a7-439f-ba46-a08...nvocation-id': b'8f726a1b-9acb-44fb-836f-e1a3173ea822', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bd3f70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bd3f70>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faee6fcbd90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6a973feb-91a7-439f-ba46-a08...nvocation-id': b'8f726a1b-9acb-44fb-836f-e1a3173ea822', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6a973feb-91a7-439f-ba46-a0815c5e8d5e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsx')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef727340>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8807ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-eb53b787-dcd7-44ee-96d1-994...nvocation-id': b'79d37758-4f21-4c10-9d1c-dc3b30c2b342', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef727340>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef727340>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8807ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-eb53b787-dcd7-44ee-96d1-994...nvocation-id': b'79d37758-4f21-4c10-9d1c-dc3b30c2b342', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-eb53b787-dcd7-44ee-96d1-994240554e60"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsm')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe59360>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeeffbcd90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-84a28ca4-f141-484b-83d7-5b7...nvocation-id': b'ccb64a9f-d891-4bc4-9c60-eaa1c19344e4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe59360>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeefe59360>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeeffbcd90>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-84a28ca4-f141-484b-83d7-5b7...nvocation-id': b'ccb64a9f-d891-4bc4-9c60-eaa1c19344e4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-84a28ca4-f141-484b-83d7-5b7a2a2a0f1e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xls')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1d120>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6c13220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1bc9b16b-d7c8-4541-a3c0-ae3...nvocation-id': b'1679848a-5e48-40d1-ae70-e07f789be003', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1d120>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6a1d120>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6c13220>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1bc9b16b-d7c8-4541-a3c0-ae3...nvocation-id': b'1679848a-5e48-40d1-ae70-e07f789be003', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1bc9b16b-d7c8-4541-a3c0-ae3b0de5ee2f"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsx')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef3594b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9cd270>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fd881eb1-c250-46c4-aa70-948...nvocation-id': b'491f21e9-89c5-4de4-8707-e87392fe2b82', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef3594b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeef3594b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9cd270>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fd881eb1-c250-46c4-aa70-948...nvocation-id': b'491f21e9-89c5-4de4-8707-e87392fe2b82', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-fd881eb1-c250-46c4-aa70-948e7f90e6f6"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsm')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6d1cbe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9b1e10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-10f5ad1d-d985-46c7-bcf4-428...nvocation-id': b'e482d981-1958-4b25-a9fa-4d18057f209b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6d1cbe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6d1cbe0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeef9b1e10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-10f5ad1d-d985-46c7-bcf4-428...nvocation-id': b'e482d981-1958-4b25-a9fa-4d18057f209b', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-10f5ad1d-d985-46c7-bcf4-4281328f3898"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('pyxlsb', '.xlsb')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef88df880>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeec2023b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4d8147ec-13ba-4f1d-ad66-5b2...nvocation-id': b'20c9ca1e-9716-4c96-9146-62dd30a02d87', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef88df880>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef88df880>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeec2023b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4d8147ec-13ba-4f1d-ad66-5b2...nvocation-id': b'20c9ca1e-9716-4c96-9146-62dd30a02d87', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-4d8147ec-13ba-4f1d-ad66-5b22b6e7748d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('odf', '.ods')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b57850>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8e7bb80>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a6d1ca9f-c884-42e3-8ef4-7ff...nvocation-id': b'808f8f72-7396-4935-a9b4-1d2b130d0635', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b57850>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b57850>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8e7bb80>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a6d1ca9f-c884-42e3-8ef4-7ff...nvocation-id': b'808f8f72-7396-4935-a9b4-1d2b130d0635', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-a6d1ca9f-c884-42e3-8ef4-7ff0ef265180"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________________ ERROR at setup of test_styler_to_s3 ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bfd0f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef8805d80>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6d2055d5-aede-4c65-86df-9e9...nvocation-id': b'dbb8973a-17f9-4fb8-9bdb-2d2e920d5b60', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bfd0f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef4bfd0f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef8805d80>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6d2055d5-aede-4c65-86df-9e9...nvocation-id': b'dbb8973a-17f9-4fb8-9bdb-2d2e920d5b60', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6d2055d5-aede-4c65-86df-9e96cd0a3b46"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[None] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef953d8a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7fae86fc5e10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-272406c9-7340-4d72-a325-9a6...nvocation-id': b'84b63bc8-cd2a-4197-bf58-d4ab20a7bd9e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef953d8a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef953d8a0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7fae86fc5e10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-272406c9-7340-4d72-a325-9a6...nvocation-id': b'84b63bc8-cd2a-4197-bf58-d4ab20a7bd9e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-272406c9-7340-4d72-a325-9a6089fe4fdb"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[gzip] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b14550>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faee6fcba60>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e0ab2164-4b5d-46c4-be8a-fa3...nvocation-id': b'f2f23a97-50bc-44e7-92a5-c83c2461136e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b14550>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b14550>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faee6fcba60>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-e0ab2164-4b5d-46c4-be8a-fa3...nvocation-id': b'f2f23a97-50bc-44e7-92a5-c83c2461136e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-e0ab2164-4b5d-46c4-be8a-fa3f58c327d3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[bz2] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb6529810>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faeec240100>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c8c0ee30-1670-4115-ab82-597...nvocation-id': b'24600378-70e3-4d31-8889-eb08461d49aa', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb6529810>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb6529810>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faeec240100>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c8c0ee30-1670-4115-ab82-597...nvocation-id': b'24600378-70e3-4d31-8889-eb08461d49aa', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c8c0ee30-1670-4115-ab82-597b8849538a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zip] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8b3d960>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7fae86fc64a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b42295df-2fd9-4c6e-9deb-95b...nvocation-id': b'08bb4cff-1c70-4096-a8ef-c63ab74589cb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8b3d960>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef8b3d960>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7fae86fc64a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b42295df-2fd9-4c6e-9deb-95b...nvocation-id': b'08bb4cff-1c70-4096-a8ef-c63ab74589cb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-b42295df-2fd9-4c6e-9deb-95b213c1652d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________________ ERROR at setup of test_with_s3_url[xz] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb65c8c10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7fae56c5ac20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d25e3bea-7ca5-45cd-a565-6e9...nvocation-id': b'2a8633cd-5244-42ef-b6ee-0bae084cbd93', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb65c8c10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeb65c8c10>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7fae56c5ac20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d25e3bea-7ca5-45cd-a565-6e9...nvocation-id': b'2a8633cd-5244-42ef-b6ee-0bae084cbd93', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d25e3bea-7ca5-45cd-a565-6e92fcaac515"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[tar] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85984130>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef6a1dde0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa03ac09-a3f5-4463-9bfe-e30...nvocation-id': b'050c71ab-5b20-4b56-a54d-692c664fe696', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85984130>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85984130>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef6a1dde0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-aa03ac09-a3f5-4463-9bfe-e30...nvocation-id': b'050c71ab-5b20-4b56-a54d-692c664fe696', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-aa03ac09-a3f5-4463-9bfe-e30a53344901"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zstd] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85911ab0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef89ae470>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f32ef66e-bfa4-4552-92e8-be8...nvocation-id': b'ede7f1e9-fd37-4176-8de9-a73936874fd6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85911ab0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7fae85911ab0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef89ae470>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f32ef66e-bfa4-4552-92e8-be8...nvocation-id': b'ede7f1e9-fd37-4176-8de9-a73936874fd6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-f32ef66e-bfa4-4552-92e8-be8753c9997c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestPandasContainer.test_read_s3_jsonl ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae56bfb8b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7fae8591e200>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-45d5163c-05a4-4597-9768-42f...nvocation-id': b'ca8e3738-2b4a-46d2-8ac6-8fd88270fa8d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7fae56bfb8b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7fae56bfb8b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7fae8591e200>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-45d5163c-05a4-4597-9768-42f...nvocation-id': b'ca8e3738-2b4a-46d2-8ac6-8fd88270fa8d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-45d5163c-05a4-4597-9768-42fd37a8d2b0"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_______________ ERROR at setup of TestPandasContainer.test_to_s3 _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b51d80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bd1360>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0bd79de1-e947-46a0-90b8-c5c...nvocation-id': b'85dc1a0b-3a46-4b45-b5fc-3bdbd75695a8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b51d80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef6b51d80>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4bd1360>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0bd79de1-e947-46a0-90b8-c5c...nvocation-id': b'85dc1a0b-3a46-4b45-b5fc-3bdbd75695a8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0bd79de1-e947-46a0-90b8-c5c503979bcd"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[lxml] _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeec203070>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7faef4ab1de0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ef7c14d1-3a65-449d-adf1-3b6...nvocation-id': b'b5254654-c5ae-4ad4-bbb4-94139fc9d30a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faeec203070>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faeec203070>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7faef4ab1de0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ef7c14d1-3a65-449d-adf1-3b6...nvocation-id': b'b5254654-c5ae-4ad4-bbb4-94139fc9d30a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ef7c14d1-3a65-449d-adf1-3b6955a89553"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[etree] ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef493a650>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7fae859844c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9de32a9b-bfe7-4270-9758-e31...nvocation-id': b'77da0376-b249-402b-9b33-81520532ef7e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7faef493a650>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7faef493a650>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7fae859844c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9de32a9b-bfe7-4270-9758-e31...nvocation-id': b'77da0376-b249-402b-9b33-81520532ef7e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9de32a9b-bfe7-4270-9758-e311117b7957"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
=================================== FAILURES ===================================
_________________ test_dataframe_to_sql[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7faef99efca0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef99efd30>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef99efca0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef99efca0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_dataframe_to_sql[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7faef88c99f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef88c9b70>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef88c99f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef88c99f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_dataframe_to_sql[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef8f5d540>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_dataframe_to_sql[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef85ca5c0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine] ___________

self = <pymysql.connections.Connection object at 0x7faef8945bd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8946b30>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8945bd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8945bd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn] ____________

self = <pymysql.connections.Connection object at 0x7faef8b1ba30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8b19780>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8b1ba30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8b1ba30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine] ________

self = <sqlalchemy.engine.base.Connection object at 0x7faef8b3d270>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn] _________

self = <sqlalchemy.engine.base.Connection object at 0x7faef86f2e00>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7faef95ec280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef95ece50>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95ec280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95ec280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7faef6cca3e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cca500>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6cca3e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6cca3e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d06530>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef8b34e80>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7faef891d480>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef891d3c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef891d480>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef891d480>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7faef6d1de40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d1df90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d1de40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d1de40>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef8a55b40>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7faef88c5510>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7faef96d3b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef96d3e80>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef96d3b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef96d3b20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7faef6d36b30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d36c80>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d36b30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d36b30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef6e5e140>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef8be6b90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7faef86d0820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef86d0220>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef86d0820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef86d0820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7faef6c799c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6c79bd0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c799c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c799c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef8f670d0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7faef9594640>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7faef8e42590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8e42770>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8e42590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8e42590>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7faef6cf1cc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cf1c30>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6cf1cc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6cf1cc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cebd90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7faef6de0af0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7faef8877fd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8876e00>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8877fd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8877fd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7faef6c96350>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6c97bb0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c96350>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c96350>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef9648100>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d19420>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ test_to_sql[None-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0x7faef6c8e5f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6c8f9d0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c8e5f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c8e5f0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_____________________ test_to_sql[None-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0x7faef91fc820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef91fdfc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef91fc820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef91fc820>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________________ test_to_sql[None-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef85a8370>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql[None-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef8dd0c10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ test_to_sql[multi-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0x7faef85c93c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef85caf20>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85c93c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85c93c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________________ test_to_sql[multi-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0x7faef9513220>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef9512590>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef9513220>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef9513220>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql[multi-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cea0b0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql[multi-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef91df730>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_to_sql_exist[replace-1-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0x7faef92243d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef92272b0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef92243d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef92243d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_exist[replace-1-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0x7faef8dc9330>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8dcae00>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8dc9330>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8dc9330>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________ test_to_sql_exist[replace-1-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d7e080>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________ test_to_sql_exist[replace-1-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0x7faef9677c70>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist[append-2-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0x7faef953ded0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef953c2e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef953ded0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef953ded0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql_exist[append-2-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0x7faef954f460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef954d8a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef954f460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef954f460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_to_sql_exist[append-2-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0x7faef9301fc0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_to_sql_exist[append-2-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0x7faef6bf39d0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql_exist_fail[mysql_pymysql_engine] _________________

self = <pymysql.connections.Connection object at 0x7faef953e9e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef953ed40>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef953e9e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef953e9e0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_to_sql_exist_fail[mysql_pymysql_conn] __________________

self = <pymysql.connections.Connection object at 0x7faef6d8ebc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d8eec0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d8ebc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d8ebc0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_to_sql_exist_fail[postgresql_psycopg2_engine] ______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef9225cf0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist_fail[postgresql_psycopg2_conn] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef967c5e0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_query[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7faef6d7c280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d7ece0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d7c280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d7c280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_query[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7faef8f66e90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8f670a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8f66e90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8f66e90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_query[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef8774c10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_query[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef94edff0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_query_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0x7faef95d3250>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef95d2bc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95d3250>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95d3250>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_query_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0x7faef87dab30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef87da590>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef87dab30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef87dab30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_query_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0x7faef95ee1d0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_query_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0x7faef9340b80>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_expression_with_parameter[mysql_pymysql_engine] _____

self = <pymysql.connections.Connection object at 0x7faef9179840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef9179990>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef9179840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef9179840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______ test_read_iris_query_expression_with_parameter[mysql_pymysql_conn] ______

self = <pymysql.connections.Connection object at 0x7faef8b37280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8b37e80>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8b37280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8b37280>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine] __

self = <sqlalchemy.engine.base.Connection object at 0x7faef88dccd0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn] ___

self = <sqlalchemy.engine.base.Connection object at 0x7faef8595390>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______ test_read_iris_query_string_with_parameter[mysql_pymysql_engine] _______

self = <pymysql.connections.Connection object at 0x7faef8687af0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef86876a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8687af0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8687af0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_read_iris_query_string_with_parameter[mysql_pymysql_conn] ________

self = <pymysql.connections.Connection object at 0x7faef6d36950>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d366e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d36950>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d36950>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0x7faef92c6ad0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0x7faef88dc430>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_table[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7faef94dcd60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef94df4c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef94dcd60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef94dcd60>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_table[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7faef96e8940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef96ebd90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef96e8940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef96e8940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_table[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef87d2cb0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_table[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cbf700>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_table_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0x7faef6c13970>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6c12b90>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c13970>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c13970>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_table_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0x7faef85efee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef85ef040>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85efee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85efee0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_table_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0x7faef8b29750>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_table_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0x7faef889d990>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql_callable[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7faef929b010>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef9299900>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef929b010>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef929b010>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_to_sql_callable[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7faef6c8e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6c8dea0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c8e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6c8e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_callable[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7faef6cebf40>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_to_sql_callable[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7faef96b9db0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_default_type_conversion[mysql_pymysql_engine] ______________

self = <pymysql.connections.Connection object at 0x7faef95df6d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef95de1a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95df6d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95df6d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_default_type_conversion[mysql_pymysql_conn] _______________

self = <pymysql.connections.Connection object at 0x7faef8807e20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8807970>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8807e20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8807e20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_read_procedure[mysql_pymysql_engine] ___________________

self = <pymysql.connections.Connection object at 0x7faef95d2080>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef95d3250>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95d2080>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef95d2080>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_procedure[mysql_pymysql_conn] ____________________

self = <pymysql.connections.Connection object at 0x7faef85aba00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef85ab7c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85aba00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef85aba00>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d7b280>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0x7faef6917490>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7faef8f67a00>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7faef95fdea0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine] ___

self = <sqlalchemy.engine.base.Connection object at 0x7faef889c760>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn] ____

self = <sqlalchemy.engine.base.Connection object at 0x7faef8eb2320>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________ test_insertion_method_on_conflict_update[mysql_pymysql_engine] ________

self = <pymysql.connections.Connection object at 0x7faef8fc1de0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef8fc0310>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8fc1de0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef8fc1de0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________ test_insertion_method_on_conflict_update[mysql_pymysql_conn] _________

self = <pymysql.connections.Connection object at 0x7faef6d79390>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7faef6d792a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d79390>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7faef6d79390>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________________ TestS3.test_read_s3_fails ___________________________

self = <aiohttp.connector.TCPConnector object at 0x7faef4c713c0>
req = <aiohttp.client_reqrep.ClientRequest object at 0x7faef6cb9ae0>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
>               return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/asyncio/base_events.py:1067: in create_connection
    raise exceptions[0]
/usr/local/lib/python3.10/asyncio/base_events.py:1052: in create_connection
    sock = await self._connect_sock(
/usr/local/lib/python3.10/asyncio/base_events.py:963: in _connect_sock
    await self.sock_connect(sock, address)
/usr/local/lib/python3.10/asyncio/selector_events.py:500: in sock_connect
    return await fut
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=True closed=False debug=False>
fut = <Future finished exception=ConnectionRefusedError(111, "Connect call failed ('127.0.0.1', 5555)")>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
address = ('127.0.0.1', 5555)

    def _sock_connect_cb(self, fut, sock, address):
        if fut.done():
            return
    
        try:
            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
            if err != 0:
                # Jump to any except clause below.
>               raise OSError(err, f'Connect call failed {address}')
E               ConnectionRefusedError: [Errno 111] Connect call failed ('127.0.0.1', 5555)

/usr/local/lib/python3.10/asyncio/selector_events.py:535: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <aiobotocore.httpsession.AIOHTTPSession object at 0x7faef6c52890>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...64c65d47dc', 'amz-sdk-invocation-id': b'01c77d1b-9bdd-4d4e-b1f0-4f5567bce47a', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
>           response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/aiohttp/client.py:536: in _request
    conn = await self._connector.connect(
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:540: in connect
    proto = await self._create_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:901: in _create_connection
    _, proto = await self._create_direct_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1206: in _create_direct_connection
    raise last_exc
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1175: in _create_direct_connection
    transp, proto = await self._wrap_create_connection(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiohttp.connector.TCPConnector object at 0x7faef4c713c0>
req = <aiohttp.client_reqrep.ClientRequest object at 0x7faef6cb9ae0>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
                return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa
        except cert_errors as exc:
            raise ClientConnectorCertificateError(req.connection_key, exc) from exc
        except ssl_errors as exc:
            raise ClientConnectorSSLError(req.connection_key, exc) from exc
        except OSError as exc:
            if exc.errno is None and isinstance(exc, asyncio.TimeoutError):
                raise
>           raise client_error(req.connection_key, exc) from exc
E           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 127.0.0.1:5555 ssl:default [Connect call failed ('127.0.0.1', 5555)]

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:988: ClientConnectorError

During handling of the above exception, another exception occurred:

self = <pandas.tests.io.parser.test_network.TestS3 object at 0x7faefc96d120>
s3so = {'client_kwargs': {'endpoint_url': 'http://127.0.0.1:5555/'}}

    def test_read_s3_fails(self, s3so):
        msg = "The specified bucket does not exist"
        with pytest.raises(OSError, match=msg):
>           read_csv("s3://nyqpug/asdf.csv", storage_options=s3so)

pandas/tests/io/parser/test_network.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/io/parsers/readers.py:945: in read_csv
    return _read(filepath_or_buffer, kwds)
pandas/io/parsers/readers.py:608: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
pandas/io/parsers/readers.py:1444: in __init__
    self._engine = self._make_engine(f, self.engine)
pandas/io/parsers/readers.py:1701: in _make_engine
    self.handles = get_handle(
pandas/io/common.py:716: in get_handle
    ioargs = _get_filepath_or_buffer(
pandas/io/common.py:418: in _get_filepath_or_buffer
    ).open()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:134: in open
    return self.__enter__()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:102: in __enter__
    f = self.fs.open(self.path, mode=mode)
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1241: in open
    f = self._open(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:659: in _open
    return S3File(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:2066: in __init__
    super().__init__(
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1597: in __init__
    self.size = self.details["size"]
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1610: in details
    self._details = self.fs.info(self.path)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:121: in wrapper
    return sync(self.loop, func, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:106: in sync
    raise return_result
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:61: in _runner
    result[0] = await coro
/usr/local/lib/python3.10/site-packages/s3fs/core.py:1271: in _info
    out = await self._call_s3(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:348: in _call_s3
    return await _error_wrapper(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:140: in _error_wrapper
    raise err
/usr/local/lib/python3.10/site-packages/s3fs/core.py:113: in _error_wrapper
    return await func(*args, **kwargs)
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:361: in _make_api_call
    http, parsed_response = await self._make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:386: in _make_request
    return await self._endpoint.make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:100: in _send_request
    while await self._needs_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:262: in _needs_retry
    responses = await self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/aiobotocore/hooks.py:66: in _emit
    response = await resolve_awaitable(handler(**kwargs))
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:107: in _call
    if await resolve_awaitable(self._checker(**checker_kwargs)):
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:126: in _call
    should_retry = await self._should_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:165: in _should_retry
    return await resolve_awaitable(
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:174: in _call
    checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:181: in _do_get_response
    http_response = await self._send(request)
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:285: in _send
    return await self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiobotocore.httpsession.AIOHTTPSession object at 0x7faef6c52890>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...64c65d47dc', 'amz-sdk-invocation-id': b'01c77d1b-9bdd-4d4e-b1f0-4f5567bce47a', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
            response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )
    
            http_response = aiobotocore.awsrequest.AioAWSResponse(
                str(response.url), response.status, response.headers, response
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                await http_response.content
    
            return http_response
        except ClientSSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (ClientProxyConnectionError, ClientHttpProxyError) as e:
            raise ProxyConnectionError(
                proxy_url=mask_proxy_url(proxy_url), error=e
            )
        except (
            ServerDisconnectedError,
            aiohttp.ClientPayloadError,
            aiohttp.http_exceptions.BadStatusLine,
        ) as e:
            raise ConnectionClosedError(
                error=e, request=request, endpoint_url=request.url
            )
        except ServerTimeoutError as e:
            if str(e).lower().startswith('connect'):
                raise ConnectTimeoutError(endpoint_url=request.url, error=e)
            else:
                raise ReadTimeoutError(endpoint_url=request.url, error=e)
        except (
            ClientConnectorError,
            ClientConnectionError,
            socket.gaierror,
        ) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/nyqpug/asdf.csv"

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:253: EndpointConnectionError
------------- generated xml file: /workspace/pandas/test-data.xml --------------
============================= slowest 30 durations =============================
28.25s call     pandas/tests/io/parser/test_network.py::TestS3::test_write_s3_csv_fails
13.22s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket
13.06s setup    pandas/tests/io/json/test_compression.py::test_with_s3_url[zstd]
12.34s setup    pandas/tests/io/test_s3.py::test_read_with_creds_from_pub_bucket
12.09s setup    pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_to_s3
11.54s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('odf', '.ods')]
11.21s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_handles_boto_s3_object
10.88s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('odf', '.ods')]
10.77s setup    pandas/tests/io/parser/test_network.py::TestS3::test_infer_s3_compression
10.75s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsx')]
10.73s setup    pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_read_s3_jsonl
10.50s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('xlrd', '.xls')]
10.26s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows
10.05s setup    pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip
9.82s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('pyxlsb', '.xlsb')]
9.61s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsx')]
9.23s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsm')]
9.13s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('xlrd', '.xls')]
9.10s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails_private
9.03s setup    pandas/tests/io/test_fsspec.py::test_s3_protocols[s3a]
8.83s call     pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails
8.71s call     pandas/tests/io/parser/test_network.py::TestS3::test_write_s3_parquet_fails
8.69s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsm')]
8.47s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked
8.41s setup    pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsx')]
8.26s setup    pandas/tests/io/json/test_compression.py::test_with_s3_url[xz]
8.05s setup    pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_python
7.67s setup    pandas/tests/io/test_fsspec.py::test_s3_protocols[s3n]
7.60s setup    pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_with_hash_in_key
7.53s setup    pandas/tests/io/json/test_compression.py::test_with_s3_url[bz2]
=========================== short test summary info ============================
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_engine] - ...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_conn] - sq...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_conn] - s...
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_conn]
FAILED pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails - b...
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_private_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3n_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3a_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_infer_s3_compression
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails_private
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_handles_boto_s3_object
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_chunked_download
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_with_hash_in_key
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_feather_s3_file_path
ERROR pandas/tests/io/test_fsspec.py::test_from_s3_csv - botocore.exceptions....
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3] - botocore.except...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3a] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3n] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_parquet - botocore.exceptions.E...
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_explicit_fs
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col0]
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col1]
ERROR pandas/tests/io/test_parquet.py::TestParquetFastParquet::test_s3_roundtrip
ERROR pandas/tests/io/test_s3.py::test_read_without_creds_from_pub_bucket - b...
ERROR pandas/tests/io/test_s3.py::test_read_with_creds_from_pub_bucket - boto...
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_style.py::test_styler_to_s3 - botocore.excep...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[None] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[gzip] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[bz2] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zip] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[xz] - botoco...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[tar] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zstd] - boto...
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_read_s3_jsonl
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_to_s3 - ...
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[lxml] - b...
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[etree] - ...
= 93 failed, 2066 passed, 177 skipped, 52 xfailed, 55 errors in 571.03s (0:09:31) =
