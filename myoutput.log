[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
============================= test session starts ==============================
platform linux -- Python 3.10.8, pytest-7.4.0, pluggy-1.2.0
rootdir: /workspace/pandas
configfile: pyproject.toml
plugins: typeguard-3.0.2, anyio-3.7.0, hypothesis-6.80.0, asyncio-0.21.0, cov-4.1.0, cython-0.2.1, localserver-0.7.1, xdist-3.3.1
asyncio: mode=strict
collected 221647 items

pandas/tests/test_aggregation.py ........
pandas/tests/test_algos.py ..................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/test_common.py ...............x................................................................................................................
pandas/tests/test_downstream.py ....s[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
.[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
.ss.ss.....
pandas/tests/test_errors.py ....................................
pandas/tests/test_expressions.py ...................................................................................................................................................................................................................................................
pandas/tests/test_flags.py .....
pandas/tests/test_multilevel.py ...................
pandas/tests/test_nanops.py .....................................................................................................................................................................................................................................................
pandas/tests/test_optional_dependency.py .....
pandas/tests/test_register_accessor.py .......
pandas/tests/test_sorting.py ......................................................
pandas/tests/test_take.py .................................................................................
pandas/tests/api/test_api.py ...........
pandas/tests/api/test_types.py ..
pandas/tests/apply/test_frame_apply.py ....................................................................................................................................................................................................
pandas/tests/apply/test_frame_apply_relabeling.py .....
pandas/tests/apply/test_frame_transform.py ...s.s.s................................................ss..ss..ss.....x........x........x........
pandas/tests/apply/test_invalid_arg.py .......................................................................................................................................................................................................
pandas/tests/apply/test_series_apply.py .............................x.....x....x.......................................................................................
pandas/tests/apply/test_series_apply_relabeling.py ..
pandas/tests/apply/test_series_transform.py ............
pandas/tests/apply/test_str.py ....................xxxxx...................................................................................................................................................................................................................................................................................................................................................................................................................................................................x...........x...........x...........x...........x........
pandas/tests/arithmetic/test_array_ops.py ....
pandas/tests/arithmetic/test_categorical.py ....
pandas/tests/arithmetic/test_datetime64.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arithmetic/test_interval.py ..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arithmetic/test_numeric.py ................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................s..s.....s..s.......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arithmetic/test_object.py ....................................................................................................................................................................................................
pandas/tests/arithmetic/test_period.py ................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arithmetic/test_timedelta64.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/test_array.py ................................................................................
pandas/tests/arrays/test_datetimelike.py ........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/test_datetimes.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/test_ndarray_backed.py .....
pandas/tests/arrays/test_period.py ...................
pandas/tests/arrays/test_timedeltas.py ......................................................................................................................................................
pandas/tests/arrays/boolean/test_arithmetic.py .....................
pandas/tests/arrays/boolean/test_astype.py ...
pandas/tests/arrays/boolean/test_comparison.py ....................................
pandas/tests/arrays/boolean/test_construction.py .............................
pandas/tests/arrays/boolean/test_function.py ...........
pandas/tests/arrays/boolean/test_indexing.py ...
pandas/tests/arrays/boolean/test_logical.py ...................................................................................
pandas/tests/arrays/boolean/test_ops.py ..
pandas/tests/arrays/boolean/test_reduction.py ..............................
pandas/tests/arrays/boolean/test_repr.py .
pandas/tests/arrays/categorical/test_algos.py ..............
pandas/tests/arrays/categorical/test_analytics.py .......x..x................................................
pandas/tests/arrays/categorical/test_api.py .................................................................
pandas/tests/arrays/categorical/test_astype.py ..........
pandas/tests/arrays/categorical/test_constructors.py .......................................................................................................................
pandas/tests/arrays/categorical/test_dtypes.py ..................................
pandas/tests/arrays/categorical/test_indexing.py ...............................................................................................................................................
pandas/tests/arrays/categorical/test_map.py .............................
pandas/tests/arrays/categorical/test_missing.py ..........................
pandas/tests/arrays/categorical/test_operators.py ...................................
pandas/tests/arrays/categorical/test_replace.py ......................
pandas/tests/arrays/categorical/test_repr.py .......................
pandas/tests/arrays/categorical/test_sorting.py ....
pandas/tests/arrays/categorical/test_subclass.py ...
pandas/tests/arrays/categorical/test_take.py ................
pandas/tests/arrays/categorical/test_warnings.py .
pandas/tests/arrays/datetimes/test_constructors.py ....................................
pandas/tests/arrays/datetimes/test_cumulative.py ...
pandas/tests/arrays/datetimes/test_reductions.py .................................................................................................................................................................................................................
pandas/tests/arrays/floating/test_arithmetic.py ..............................................................
pandas/tests/arrays/floating/test_astype.py .........
pandas/tests/arrays/floating/test_comparison.py ..................................................................................................................
pandas/tests/arrays/floating/test_concat.py ...
pandas/tests/arrays/floating/test_construction.py ...............................
pandas/tests/arrays/floating/test_contains.py .
pandas/tests/arrays/floating/test_function.py ....................................................
pandas/tests/arrays/floating/test_repr.py ........
pandas/tests/arrays/floating/test_to_numpy.py ..................................
pandas/tests/arrays/integer/test_arithmetic.py ...................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/integer/test_comparison.py .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/integer/test_concat.py ..................
pandas/tests/arrays/integer/test_construction.py ...............................................
pandas/tests/arrays/integer/test_dtypes.py ..........................................................................................................................
pandas/tests/arrays/integer/test_function.py .............................................................................................................................
pandas/tests/arrays/integer/test_indexing.py ..
pandas/tests/arrays/integer/test_repr.py ..........................
pandas/tests/arrays/interval/test_astype.py ..
pandas/tests/arrays/interval/test_interval.py ...................................................................................................
pandas/tests/arrays/interval/test_ops.py ....................................................................................................................
pandas/tests/arrays/masked/test_arithmetic.py ..............................................................................................................................................ss........................................................................................................................................................ss........................................................................................................................................................ss........................................................................................................................................................ss........................................................................................................................................................ss...............................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/masked/test_arrow_compat.py ...........................................................................................
pandas/tests/arrays/masked/test_function.py ....................
pandas/tests/arrays/masked/test_indexing.py ...........................................................................................................
pandas/tests/arrays/numpy_/test_indexing.py .......................................
pandas/tests/arrays/numpy_/test_numpy.py .......................................................................................
pandas/tests/arrays/period/test_arrow_compat.py .xx....
pandas/tests/arrays/period/test_astype.py ..........
pandas/tests/arrays/period/test_constructors.py ....................
pandas/tests/arrays/period/test_reductions.py ...
pandas/tests/arrays/sparse/test_accessor.py .............................................
pandas/tests/arrays/sparse/test_arithmetics.py ......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/arrays/sparse/test_array.py ...........................................................................
pandas/tests/arrays/sparse/test_astype.py ........................
pandas/tests/arrays/sparse/test_combine_concat.py ..........
pandas/tests/arrays/sparse/test_constructors.py .................................
pandas/tests/arrays/sparse/test_dtype.py ........................................................
pandas/tests/arrays/sparse/test_indexing.py ...............................................................................
pandas/tests/arrays/sparse/test_libsparse.py .....................................................................................
pandas/tests/arrays/sparse/test_reductions.py .......................................................................
pandas/tests/arrays/sparse/test_unary.py .........
pandas/tests/arrays/string_/test_string.py ...............x...xxxxx.........................................................................xxxxxxxx..............xx.....................s............................
pandas/tests/arrays/string_/test_string_arrow.py ....s....s................................
pandas/tests/arrays/timedeltas/test_constructors.py .......
pandas/tests/arrays/timedeltas/test_cumulative.py ..
pandas/tests/arrays/timedeltas/test_reductions.py .......................
pandas/tests/base/test_constructors.py .......................
pandas/tests/base/test_conversion.py ...........................................................................................................................................................................................................................................................................x.....................................
pandas/tests/base/test_fillna.py ....................................................................................ssssssssssssssssss....ssss........ssssssssss......ss................................................ss........................ssssssssssss
pandas/tests/base/test_misc.py ............................................................................................................................................................................................................................................xx...xxx......................................................................s.......
pandas/tests/base/test_transpose.py ....................................................................................................................................................................................................................................
pandas/tests/base/test_unique.py ....................................................................................ssssssssssssssssss....ssss........ssssssssss......ss................................................ss........................ssssssssssss....................................................................................ssssssssssssssssss....ssss..........ssssssss......ss..........................................................................ssssssssssss....
pandas/tests/base/test_value_counts.py ....................................................................................ssssssssssssssssss....ssss........ssssssssss......ss................................................ss........................ssssssssssss..........
pandas/tests/computation/test_compat.py .....
pandas/tests/computation/test_eval.py ..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx..............................xx..............................xx..............................xx...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................X.........X....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x....................................................................................................................................................................................................................................xx..xx.....
pandas/tests/config/test_config.py .....................
pandas/tests/config/test_localization.py .............................
pandas/tests/construction/test_extract_array.py .
pandas/tests/copy_view/test_array.py .............
pandas/tests/copy_view/test_astype.py .......................
pandas/tests/copy_view/test_clip.py .....
pandas/tests/copy_view/test_constructors.py ............................................................................
pandas/tests/copy_view/test_core_functionalities.py ......
pandas/tests/copy_view/test_functions.py ....................
pandas/tests/copy_view/test_indexing.py ....................................................................................s.....s..........................................................................................................................
pandas/tests/copy_view/test_internals.py ....................
pandas/tests/copy_view/test_interp_fillna.py ...................................................................
pandas/tests/copy_view/test_methods.py ...................................................................................................................................................................................................................................................
pandas/tests/copy_view/test_replace.py ....................................
pandas/tests/copy_view/test_setitem.py ........
pandas/tests/copy_view/test_util.py ..
pandas/tests/copy_view/index/test_datetimeindex.py ......
pandas/tests/copy_view/index/test_index.py .....................
pandas/tests/copy_view/index/test_periodindex.py ..
pandas/tests/copy_view/index/test_timedeltaindex.py ..
pandas/tests/dtypes/test_common.py ............................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/dtypes/test_concat.py ....
pandas/tests/dtypes/test_dtypes.py ......................................................................................................................................................................................................................................................................................
pandas/tests/dtypes/test_generic.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/dtypes/test_inference.py ......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/dtypes/test_missing.py ......................................................................................x.x.x.xxxx.............................................................................................................................................................................................................
pandas/tests/dtypes/cast/test_can_hold_element.py ...........
pandas/tests/dtypes/cast/test_construct_from_scalar.py ....
pandas/tests/dtypes/cast/test_construct_ndarray.py .......
pandas/tests/dtypes/cast/test_construct_object_arr.py .......................................
pandas/tests/dtypes/cast/test_dict_compat.py .
pandas/tests/dtypes/cast/test_downcast.py ...................................
pandas/tests/dtypes/cast/test_find_common_type.py ..........................................................................................
pandas/tests/dtypes/cast/test_infer_datetimelike.py ...
pandas/tests/dtypes/cast/test_infer_dtype.py ....................................................................
pandas/tests/dtypes/cast/test_maybe_box_native.py ................
pandas/tests/dtypes/cast/test_promote.py ..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/extension/test_arrow.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................x.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx.....................................................................................x...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ssssssssssssssssssss..................................................ssssssss......................................................................................................................................................................................................................................................................xxssssssssssssssssssssssssssssssssssssssssssssssss........xxxxxxxxxxxxxxxxxxxxxxxxssssssssssssssssssssssssssssssssssssssssssssssssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx..............................................................................ss..............................................................................ss..............................................................................ss..............................................................................ss..............................................................................ss..............................................................................ss..............................................................................xx..............................................................................xx..............................................................................xxxxxxxxxxxxxxxxxxxxxxxx........................................................xxxxxxxxxxxxxxxxxxxxxxxx........................................................xx..............................................................................xx.........................xxxx............................................................................xxxx......................................................................................................................................................................................................................................................................................................................................................................................x.......................................x..............................................................................xx..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x.......................................x...............................................................................x.xxxxxxx.xxx.xxx.xxx.xxx.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x...x..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx........................................xxxx....xxxx........................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx............................................................................................................................................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x.x.x.x...............ssss.............................................................................................................................................................................x.......................................................................................................................................................................................................................................................................................................................................................................x...............................................................................x.......................................x.....................................................................................................................................................................................................................................................................................................xxxx....................................xxxx...............................................................................................................................................xxxxxxxx..x...............................................................................x.....................................................................xxxxxxxxxxx................................................................................ss........................................................................................................................xxxx....................................xxxx...............................................................................................................................................xxxxxxxx..x...............................................................................x.....................................................................xxxxxxxxxxx................................................................................ss...........................................................................................................xxxx.........xxxx.......................xxxx.........xxxx...............................................................................................................................................xxxxxxxx..x...............................................................................x.....................................................................xxxxxxxxxxx.................................................................................................................x..................................x.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x...................................................................................................................................................................................................................................................................................................xx.........xxxxxxxxxxxxxxxxxxxx.............................................................................................................................................
pandas/tests/extension/test_boolean.py ......................................................................xx....................................................x.....................................................................................................xx..................................................................................................................................................................................................................................................................................
pandas/tests/extension/test_categorical.py ..................................x................................................................xx.................s...................................x..........................................................................................................................................................ss.....................................................xx.........................................xx.............x.............x......................................................
pandas/tests/extension/test_common.py ...........
pandas/tests/extension/test_datetime.py ........................................................xx...............................................................................................................................................................................................................................................................................................................x.........................................................................................
pandas/tests/extension/test_extension.py ..............
pandas/tests/extension/test_external_block.py .
pandas/tests/extension/test_floating.py ..................................................................................................................................................................................................................................................................................................................................xxxx......................................................................................................x...x.......................................................................................................................................................................................................................................................................................................................................................................................................................................................ssssssss..............................................................................................................
pandas/tests/extension/test_integer.py ........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxxxxxxxxxx..................................................................................................................................................................................................................................................................................................................................................................................................................x...x...x...x...x...x...x...x...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ssssssssssssssssssssssssssssssss........................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/extension/test_interval.py ....................................................................xx.....................................................................................................................................ss.....................................................xx..........xxxxx..................................................................x..........................................x..
pandas/tests/extension/test_numpy.py ..................................................ss.x.........................................x......................................xxxx..................................x....................................................x.......................................................................................................................................................................................................................x.x.x.x.xxx.x.x.......x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.....x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x......................xx..xx.............................x.x.................................................................................................................................................x.x.x..xx.x..xx..xx...xxx...xxx.x...x...x.x.x................xx................................................................
pandas/tests/extension/test_period.py ................................................................................................................xxxx............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x...x...................................................................................................................................................................................
pandas/tests/extension/test_sparse.py ...............................xx............................xx..............................xx......................................xx......s.s.s.s.s.s.xx......................................xxxx.............................xx..s.....................xx.......x....x..............................................................................................................................................................................................................xx....xx..........ss..ssssss.......................................xx..xx..........xxssssssssssssss..............ssssssssssssss..............xxxx....xx.x................xx............xxxxxxxxxxxxxxxxxxxxxxxx........xxxxxx....................................
pandas/tests/extension/test_string.py ......s.............s...s.................ss..........s...s...s...s...s...s...s...s...s...s...s...s...s...ss.ss...s...s.......s...ss......s...s...s...s.......s....ss......ss......s...s...s...s...s...s...s...s...s...s...s...s...s...ss......ssssssss........................s...s...ss.ss...s...s...s...s...s...s...s...s...s...s...s...s...s...sss.........ss......ssxxxxxxs...s...s...s...s...s...s...s...s...ss......s...s...s...s...s....s...s...s...s...s...s...s...s...s...s...ss......s...s...s...s...s...s...sss.........sss.........s...s...s...s...sss.........sss.........ssss.x...x...x..ssss............ss......s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...ss.ss...s...s...ss......s...s...s...s...s...s...s...s...s...s...s...s...s...ss......ss......ss......ss......ss......ss......ss......ss......ss......ss......ss......ss......ss......ss......s...s...ss......ss......s...s...s...ss......s...s...s...s...ss......ss......ssssssss........................s...ss......ss......ss......ss......ss......ss......ssss............s...s...s...s...s...s...s...s...s...ssssss..................s...sssssssssssss...............sssss...............s...s...s...s...s...s...s...s...s...ssss............ssss............ssss............ssss............ssss............ssss............s...s...s...s...sss.........sss.........s...s...s...s...s...s...s...ss......s.....ss......s...s...s...s...s...s...ss......s...s...s...s...s...s...ss......ss......s...s...s...s...s...s....s...s...s...s...ss......s...s...s...s...ss.sss.sss.sss.sss.sss.sss.sss.sss.sss.sss.sssss..ssssssssssssss......ssssssssssssssssss......ssssssssssssssssss......sssssss...s...
pandas/tests/extension/array_with_attr/test_array_with_attr.py .
pandas/tests/extension/decimal/test_decimal.py ....................................................................................................xx................................................................................................................................................................................................................................................x............................................x................................................................................
pandas/tests/extension/json/test_json.py ....................................x...........xxxx....................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...................xx.................................xx.............................s........................................ss...........................................xxxx........xxXxxxxs...........x....xxxxx.............................xxxxx.xx.xxxxxxx.x....................
pandas/tests/extension/list/test_list.py .
pandas/tests/frame/test_alter_axes.py ..
pandas/tests/frame/test_api.py .................................
pandas/tests/frame/test_arithmetic.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/frame/test_block_internals.py ...................
pandas/tests/frame/test_constructors.py .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xxxx..xx..........xxxx..xx................................
pandas/tests/frame/test_cumulative.py .......
pandas/tests/frame/test_iteration.py ..........
pandas/tests/frame/test_logical_ops.py .................
pandas/tests/frame/test_nonunique_indexes.py ................
pandas/tests/frame/test_npfuncs.py ....
pandas/tests/frame/test_query_eval.py ..................ss..ss..ss.......................s.......................s..s......sssss.................................................s........................s..s.....sssss...............................................ss..ss......................ss..................................................................................................
pandas/tests/frame/test_reductions.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x.............x............................................................
pandas/tests/frame/test_repr_info.py .......................................
pandas/tests/frame/test_stack_unstack.py .....................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/frame/test_subclass.py ..............................................
pandas/tests/frame/test_ufunc.py ....xx.........xxxxxxxx.xx......
pandas/tests/frame/test_unary.py ..................
pandas/tests/frame/test_validate.py ............................
pandas/tests/frame/constructors/test_from_dict.py .............
pandas/tests/frame/constructors/test_from_records.py .........................
pandas/tests/frame/indexing/test_coercion.py .......x.x.
pandas/tests/frame/indexing/test_delitem.py ....
pandas/tests/frame/indexing/test_get.py ....
pandas/tests/frame/indexing/test_get_value.py ..
pandas/tests/frame/indexing/test_getitem.py .......................................
pandas/tests/frame/indexing/test_indexing.py .................................................................................................................................................................................................................................
pandas/tests/frame/indexing/test_insert.py .......
pandas/tests/frame/indexing/test_mask.py ...........
pandas/tests/frame/indexing/test_set_value.py ...
pandas/tests/frame/indexing/test_setitem.py ..................................................................................................................................................................................................xxx...........................x..x..x..x.....
pandas/tests/frame/indexing/test_take.py ....
pandas/tests/frame/indexing/test_where.py .............................................................................................................................................
pandas/tests/frame/indexing/test_xs.py ..............................
pandas/tests/frame/methods/test_add_prefix_suffix.py ...
pandas/tests/frame/methods/test_align.py ........................................................................
pandas/tests/frame/methods/test_asfreq.py ..............................
pandas/tests/frame/methods/test_asof.py ...........
pandas/tests/frame/methods/test_assign.py .....
pandas/tests/frame/methods/test_astype.py .................................................................................................................................................................................................................................................
pandas/tests/frame/methods/test_at_time.py ......................
pandas/tests/frame/methods/test_between_time.py ..............................
pandas/tests/frame/methods/test_clip.py ....................
pandas/tests/frame/methods/test_combine.py .....
pandas/tests/frame/methods/test_combine_first.py ..................................................
pandas/tests/frame/methods/test_compare.py .........................
pandas/tests/frame/methods/test_convert_dtypes.py .............
pandas/tests/frame/methods/test_copy.py .....
pandas/tests/frame/methods/test_count.py ..
pandas/tests/frame/methods/test_cov_corr.py ..........................................................................
pandas/tests/frame/methods/test_describe.py ................................................
pandas/tests/frame/methods/test_diff.py .....................................
pandas/tests/frame/methods/test_dot.py ................
pandas/tests/frame/methods/test_drop.py .........................................................................
pandas/tests/frame/methods/test_drop_duplicates.py .....................................
pandas/tests/frame/methods/test_droplevel.py ..
pandas/tests/frame/methods/test_dropna.py ...................
pandas/tests/frame/methods/test_dtypes.py ........
pandas/tests/frame/methods/test_duplicated.py .......xxx...........
pandas/tests/frame/methods/test_equals.py ...
pandas/tests/frame/methods/test_explode.py .....................
pandas/tests/frame/methods/test_fillna.py .......................................................
pandas/tests/frame/methods/test_filter.py .........
pandas/tests/frame/methods/test_first_and_last.py .............
pandas/tests/frame/methods/test_first_valid_index.py ...............
pandas/tests/frame/methods/test_get_numeric_data.py ....
pandas/tests/frame/methods/test_head_tail.py ....................................................................
pandas/tests/frame/methods/test_infer_objects.py .
pandas/tests/frame/methods/test_interpolate.py .............................................
pandas/tests/frame/methods/test_is_homogeneous_dtype.py .......
pandas/tests/frame/methods/test_isetitem.py ...
pandas/tests/frame/methods/test_isin.py .................
pandas/tests/frame/methods/test_iterrows.py .
pandas/tests/frame/methods/test_join.py ..............................
pandas/tests/frame/methods/test_map.py .........................
pandas/tests/frame/methods/test_matmul.py ..
pandas/tests/frame/methods/test_nlargest.py .........................................................................................................................................................................................................................................................................................
pandas/tests/frame/methods/test_pct_change.py ............................
pandas/tests/frame/methods/test_pipe.py ......
pandas/tests/frame/methods/test_pop.py ...
pandas/tests/frame/methods/test_quantile.py ...............................................................xx..........xx..........xx..........xx..................
pandas/tests/frame/methods/test_rank.py ................................................................................................................
pandas/tests/frame/methods/test_reindex.py .................................................................................................................................................
pandas/tests/frame/methods/test_reindex_like.py .....
pandas/tests/frame/methods/test_rename.py .........................
pandas/tests/frame/methods/test_rename_axis.py .........
pandas/tests/frame/methods/test_reorder_levels.py ...
pandas/tests/frame/methods/test_replace.py ..............................................................................................................................................................................................................
pandas/tests/frame/methods/test_reset_index.py ........................................................................................
pandas/tests/frame/methods/test_round.py .........
pandas/tests/frame/methods/test_sample.py ..........................................................
pandas/tests/frame/methods/test_select_dtypes.py ...........................................
pandas/tests/frame/methods/test_set_axis.py ..............
pandas/tests/frame/methods/test_set_index.py .................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/frame/methods/test_shift.py ...................................................................................x.x.x.x.x.xxxx..
pandas/tests/frame/methods/test_size.py .....
pandas/tests/frame/methods/test_sort_index.py ..............................................................
pandas/tests/frame/methods/test_sort_values.py ........................................................................................................................
pandas/tests/frame/methods/test_swapaxes.py ....
pandas/tests/frame/methods/test_swaplevel.py .
pandas/tests/frame/methods/test_to_csv.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/frame/methods/test_to_dict.py ...............................................................................................
pandas/tests/frame/methods/test_to_dict_of_blocks.py ....
pandas/tests/frame/methods/test_to_numpy.py ....
pandas/tests/frame/methods/test_to_period.py ........................................................................
pandas/tests/frame/methods/test_to_records.py ...................................
pandas/tests/frame/methods/test_to_timestamp.py ........................................................................
pandas/tests/frame/methods/test_transpose.py ..............
pandas/tests/frame/methods/test_truncate.py ........................................................................................
pandas/tests/frame/methods/test_tz_convert.py ...........
pandas/tests/frame/methods/test_tz_localize.py .........
pandas/tests/frame/methods/test_update.py .............
pandas/tests/frame/methods/test_value_counts.py ...............................
pandas/tests/frame/methods/test_values.py ...............
pandas/tests/generic/test_duplicate_labels.py ..........xx...........x.......xx.xxx................x................
pandas/tests/generic/test_finalize.py ...........................x..................................x........x.........x....................................................................................x..x....xs..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x.s..s...s..s..x..x.x...x.s..s...s..s.x..x..x...x........................................................................................xxxxxxxxx..........xxxxxxxxxxxx.
pandas/tests/generic/test_frame.py ...............
pandas/tests/generic/test_generic.py ....................................................................................
pandas/tests/generic/test_label_or_level_utils.py .......................................................................
pandas/tests/generic/test_series.py ...................
pandas/tests/generic/test_to_xarray.py ......................s.........................................
pandas/tests/groupby/test_any_all.py .........................................................................................................................
pandas/tests/groupby/test_api.py ......s..s............................................................
pandas/tests/groupby/test_apply.py ...............................................................................................................................
pandas/tests/groupby/test_apply_mutate.py .....
pandas/tests/groupby/test_bin_groupby.py ......
pandas/tests/groupby/test_categorical.py ..................................................................................................................................x.........................................................................................................................................................................................................................................................................xx.xx.xx.xx.................................................................................................................................................................................................................................................xx.xx.xx.xx......................................................................................ss.ss.ss.ssxxxxxx.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ssxxxxxx.ss.ss.ss.ssxxsxxsxxsxxs.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ssxxxxxx.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ssxxxxxx.ss.ss.ss.ssxxsxxsxxsxxs.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss.ss......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................s........s........s........s........s........s........s........s...ss.sssss.ss.sssss.ss.sssss.ss.sssss.ss.sssss.ss.sssss.ss.sssss.ss.sssss...................ss.ss.ss.ss.ss.ss.................sxsx................................................................................sxsx................................................................................sxsx................................................................................sxsx.......................................x................................
pandas/tests/groupby/test_counting.py .................................
pandas/tests/groupby/test_filters.py ..........................
pandas/tests/groupby/test_function.py ........................................................................xxx......ssssss..............................xxx..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx..............................................................................................................................................
pandas/tests/groupby/test_groupby.py ....................................s..........................................................................................................................xx..........................................xx..........................................xx..........................................xx..........................................xx..........................................xx..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx..........................................xx..........................................xx..........................................xx..........................................xx..........................................xx...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ss..........ss..............ss.................................................................................................................................................
pandas/tests/groupby/test_groupby_dropna.py ........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx.xx.xx.xx.............xx.xx.xx.xx.................................................................................................................................................................................................................................................................................................................................................................................................................xxxxxxxx..................................................
pandas/tests/groupby/test_groupby_shift_diff.py ..................................
pandas/tests/groupby/test_groupby_subclass.py .....s.................................................................
pandas/tests/groupby/test_grouping.py ..........................................................................
pandas/tests/groupby/test_index_as_string.py ..................
pandas/tests/groupby/test_indexing.py ............................................................................................................................................................................
pandas/tests/groupby/test_libgroupby.py ...........................
pandas/tests/groupby/test_min_max.py ......................
pandas/tests/groupby/test_missing.py .........................
pandas/tests/groupby/test_nth.py ...................................................................................................................................................................................................................
pandas/tests/groupby/test_numba.py ..........................................................................................................................................................
pandas/tests/groupby/test_nunique.py ............................................
pandas/tests/groupby/test_pipe.py ..
pandas/tests/groupby/test_quantile.py ..................................................................................................x....x.......................................................................................................................................................................................................................
pandas/tests/groupby/test_raises.py .....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/groupby/test_rank.py .............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/groupby/test_sample.py ..............
pandas/tests/groupby/test_size.py .......x....x....x....x....x....x....x....x...........
pandas/tests/groupby/test_skew.py .
pandas/tests/groupby/test_timegrouper.py ..............................
pandas/tests/groupby/test_value_counts.py .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/groupby/aggregate/test_aggregate.py .............................................................................................................................................................................................................................................................................................................................................x..x.......................................................................x.....
pandas/tests/groupby/aggregate/test_cython.py .....................................................................................................................................................................
pandas/tests/groupby/aggregate/test_numba.py ................................x............................
pandas/tests/groupby/aggregate/test_other.py ........................................
pandas/tests/groupby/transform/test_numba.py ...............................................................................
pandas/tests/groupby/transform/test_transform.py ..................x.........................................................................................................................................................................................................................................................................................................................x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x....................................................................................x....................x....................................................................................................................................................................................................
pandas/tests/indexes/test_any_index.py .....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/test_base.py ..........................................................................................................................................................................x............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/test_common.py ...............................................................................................................................................................................................................................................................................................................................................sssssssss...s....ss...........................xs......................sss................................................sss.........................................................................................s................s.........................................................................................................................................................................................................................................................................................xx.............................................
pandas/tests/indexes/test_datetimelike.py ....................................
pandas/tests/indexes/test_engines.py .........................................
pandas/tests/indexes/test_frozen.py ..........
pandas/tests/indexes/test_index_new.py ............................................xxxx.................................................................................................................
pandas/tests/indexes/test_indexing.py .............................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/test_numpy_compat.py ................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/test_old_base.py s...s...................sss.............................s...s......s..ssssssssss.................s.............s................................................................................................................................................................ssssssss..s..sssssssss..s..sssssssss..s..sssssssss..s..sssssssss..s..s..................................................................................................................................................ssssssss....s.s...s.....s.....................................................................................................................................................ss......................ssssss.........................................................................................................................................................................s......................................................................................................................................................................................s...s...........s...s...........................................................................................s...s...
pandas/tests/indexes/test_setops.py ......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................X.............................................................................................................................................................................X.........X...................................................................................................................X...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ssssssssss..........sssss..........sssss...............sssss..........................................................................................ssssssssss..........sssss..........sssss...............sssss..........................................................................................ssssssssss..........sssss..........sssss...............sssss..........................................................................................ssssssssss..........sssss..........sssss...............sssss..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/test_subclass.py .
pandas/tests/indexes/base_class/test_constructors.py .......
pandas/tests/indexes/base_class/test_formats.py .............
pandas/tests/indexes/base_class/test_indexing.py .............
pandas/tests/indexes/base_class/test_pickle.py .
pandas/tests/indexes/base_class/test_reshape.py ..................
pandas/tests/indexes/base_class/test_setops.py ............................................................
pandas/tests/indexes/base_class/test_where.py .
pandas/tests/indexes/categorical/test_append.py .......
pandas/tests/indexes/categorical/test_astype.py ...........
pandas/tests/indexes/categorical/test_category.py ........................................
pandas/tests/indexes/categorical/test_constructors.py .....
pandas/tests/indexes/categorical/test_equals.py ....
pandas/tests/indexes/categorical/test_fillna.py ...
pandas/tests/indexes/categorical/test_formats.py ..
pandas/tests/indexes/categorical/test_indexing.py .................................
pandas/tests/indexes/categorical/test_map.py .....................
pandas/tests/indexes/categorical/test_reindex.py .......
pandas/tests/indexes/datetimelike_/test_drop_duplicates.py ................................................................................................................
pandas/tests/indexes/datetimelike_/test_equals.py .....................
pandas/tests/indexes/datetimelike_/test_indexing.py ................
pandas/tests/indexes/datetimelike_/test_is_monotonic.py .
pandas/tests/indexes/datetimelike_/test_nat.py ......................
pandas/tests/indexes/datetimelike_/test_sort_values.py ...................................................................................
pandas/tests/indexes/datetimelike_/test_value_counts.py ............................................
pandas/tests/indexes/datetimes/test_asof.py ..
pandas/tests/indexes/datetimes/test_constructors.py ......................................................................................................................................................................................................................................................
pandas/tests/indexes/datetimes/test_date_range.py ...................................................................................................................................................................................................................
pandas/tests/indexes/datetimes/test_datetime.py ....................x..............
pandas/tests/indexes/datetimes/test_datetimelike.py .
pandas/tests/indexes/datetimes/test_delete.py ..
pandas/tests/indexes/datetimes/test_formats.py ................
pandas/tests/indexes/datetimes/test_freq_attr.py ..........................
pandas/tests/indexes/datetimes/test_indexing.py .....................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/datetimes/test_join.py ......................
pandas/tests/indexes/datetimes/test_map.py .....
pandas/tests/indexes/datetimes/test_misc.py ..............
pandas/tests/indexes/datetimes/test_npfuncs.py .
pandas/tests/indexes/datetimes/test_ops.py ....................................................................................................................................................................................................
pandas/tests/indexes/datetimes/test_partial_slicing.py ..................................
pandas/tests/indexes/datetimes/test_pickle.py ......
pandas/tests/indexes/datetimes/test_reindex.py ..
pandas/tests/indexes/datetimes/test_scalar_compat.py ......................................................................................................................
pandas/tests/indexes/datetimes/test_setops.py ..........................................................................................................................
pandas/tests/indexes/datetimes/test_timezones.py .................................................................................................................................................................................................................
pandas/tests/indexes/datetimes/test_unique.py ........................
pandas/tests/indexes/datetimes/methods/test_astype.py ..............................
pandas/tests/indexes/datetimes/methods/test_factorize.py ....................................................................................
pandas/tests/indexes/datetimes/methods/test_fillna.py ..
pandas/tests/indexes/datetimes/methods/test_insert.py ..............................................................................................................................................................................
pandas/tests/indexes/datetimes/methods/test_isocalendar.py .
pandas/tests/indexes/datetimes/methods/test_repeat.py ........................................
pandas/tests/indexes/datetimes/methods/test_shift.py ..................................
pandas/tests/indexes/datetimes/methods/test_snap.py ........................
pandas/tests/indexes/datetimes/methods/test_to_frame.py ..
pandas/tests/indexes/datetimes/methods/test_to_period.py ..................................
pandas/tests/indexes/datetimes/methods/test_to_series.py .
pandas/tests/indexes/interval/test_astype.py ....................................x...........................................................................................................................
pandas/tests/indexes/interval/test_base.py ..........
pandas/tests/indexes/interval/test_constructors.py ..........................................................................................................................................................................................................................................................................ssssssss.......................................s.................s.....s.....s.....s....................................ssssssss.......................................s.................s.....s.....s.....s....................
pandas/tests/indexes/interval/test_equals.py ....
pandas/tests/indexes/interval/test_formats.py ........
pandas/tests/indexes/interval/test_indexing.py ..............................................................................................................................................................................................................................................................................
pandas/tests/indexes/interval/test_interval.py .........................................................................................................................................................................................................................................................
pandas/tests/indexes/interval/test_interval_range.py ......................................................................................................................................................
pandas/tests/indexes/interval/test_interval_tree.py ....................................................................................................................................................................................................................
pandas/tests/indexes/interval/test_join.py ...
pandas/tests/indexes/interval/test_pickle.py ...
pandas/tests/indexes/interval/test_setops.py .................................................................................
pandas/tests/indexes/multi/test_analytics.py ......................................
pandas/tests/indexes/multi/test_astype.py ...
pandas/tests/indexes/multi/test_compat.py ......
pandas/tests/indexes/multi/test_constructors.py ....................................................................................................
pandas/tests/indexes/multi/test_conversion.py ......
pandas/tests/indexes/multi/test_copy.py ..........
pandas/tests/indexes/multi/test_drop.py .............
pandas/tests/indexes/multi/test_duplicates.py ..................................................
pandas/tests/indexes/multi/test_equivalence.py ..............
pandas/tests/indexes/multi/test_formats.py .............
pandas/tests/indexes/multi/test_get_level_values.py .......
pandas/tests/indexes/multi/test_get_set.py ...................
pandas/tests/indexes/multi/test_indexing.py ......................................................................................................................................
pandas/tests/indexes/multi/test_integrity.py .................
pandas/tests/indexes/multi/test_isin.py ..............
pandas/tests/indexes/multi/test_join.py ...........................................................
pandas/tests/indexes/multi/test_lexsort.py ..
pandas/tests/indexes/multi/test_missing.py ...x..
pandas/tests/indexes/multi/test_monotonic.py ...........
pandas/tests/indexes/multi/test_names.py ...............................
pandas/tests/indexes/multi/test_partial_indexing.py .....
pandas/tests/indexes/multi/test_pickle.py .
pandas/tests/indexes/multi/test_reindex.py ............
pandas/tests/indexes/multi/test_reshape.py ..........
pandas/tests/indexes/multi/test_setops.py ...................................................................................................................................................................................................................................................................................
pandas/tests/indexes/multi/test_sorting.py .........................
pandas/tests/indexes/multi/test_take.py ...
pandas/tests/indexes/numeric/test_astype.py ...................
pandas/tests/indexes/numeric/test_indexing.py ................................................................................................................................................................................................................................................................
pandas/tests/indexes/numeric/test_join.py ...........
pandas/tests/indexes/numeric/test_numeric.py .............................................................................................
pandas/tests/indexes/numeric/test_setops.py ...................
pandas/tests/indexes/object/test_astype.py ..
pandas/tests/indexes/object/test_indexing.py .......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexes/period/test_constructors.py ..........................................................................
pandas/tests/indexes/period/test_formats.py ......
pandas/tests/indexes/period/test_freq_attr.py .
pandas/tests/indexes/period/test_indexing.py .........................................................................
pandas/tests/indexes/period/test_join.py ...........
pandas/tests/indexes/period/test_monotonic.py ..
pandas/tests/indexes/period/test_partial_slicing.py ..............
pandas/tests/indexes/period/test_period.py .......................................................................................................................................................
pandas/tests/indexes/period/test_period_range.py ........
pandas/tests/indexes/period/test_pickle.py ....
pandas/tests/indexes/period/test_resolution.py .........
pandas/tests/indexes/period/test_scalar_compat.py ...
pandas/tests/indexes/period/test_searchsorted.py ........
pandas/tests/indexes/period/test_setops.py ..............
pandas/tests/indexes/period/test_tools.py ............
pandas/tests/indexes/period/methods/test_asfreq.py ......
pandas/tests/indexes/period/methods/test_astype.py ..........
pandas/tests/indexes/period/methods/test_factorize.py ..
pandas/tests/indexes/period/methods/test_fillna.py .
pandas/tests/indexes/period/methods/test_insert.py ...
pandas/tests/indexes/period/methods/test_is_full.py .
pandas/tests/indexes/period/methods/test_repeat.py ......
pandas/tests/indexes/period/methods/test_shift.py ......
pandas/tests/indexes/period/methods/test_to_timestamp.py ........
pandas/tests/indexes/ranges/test_constructors.py .............................
pandas/tests/indexes/ranges/test_indexing.py ..........
pandas/tests/indexes/ranges/test_join.py ..........
pandas/tests/indexes/ranges/test_range.py .................................................................................
pandas/tests/indexes/ranges/test_setops.py ...................................................................
pandas/tests/indexes/timedeltas/test_constructors.py ....................
pandas/tests/indexes/timedeltas/test_delete.py ...
pandas/tests/indexes/timedeltas/test_formats.py ....
pandas/tests/indexes/timedeltas/test_freq_attr.py ...........
pandas/tests/indexes/timedeltas/test_indexing.py ....................................
pandas/tests/indexes/timedeltas/test_join.py .......
pandas/tests/indexes/timedeltas/test_ops.py ..........
pandas/tests/indexes/timedeltas/test_pickle.py .
pandas/tests/indexes/timedeltas/test_scalar_compat.py ........
pandas/tests/indexes/timedeltas/test_searchsorted.py ........
pandas/tests/indexes/timedeltas/test_setops.py ................................
pandas/tests/indexes/timedeltas/test_timedelta.py ........
pandas/tests/indexes/timedeltas/test_timedelta_range.py ..................
pandas/tests/indexes/timedeltas/methods/test_astype.py ..........
pandas/tests/indexes/timedeltas/methods/test_factorize.py ..
pandas/tests/indexes/timedeltas/methods/test_fillna.py .
pandas/tests/indexes/timedeltas/methods/test_insert.py ...............
pandas/tests/indexes/timedeltas/methods/test_repeat.py .
pandas/tests/indexes/timedeltas/methods/test_shift.py ......
pandas/tests/indexing/test_at.py .........................................
pandas/tests/indexing/test_categorical.py .................................................................................................................
pandas/tests/indexing/test_chaining_and_caching.py ...............................
pandas/tests/indexing/test_check_indexer.py .........................
pandas/tests/indexing/test_coercion.py ..........xxxxxxx...............................................................xx........................................xxxx....x............................................................xxxxx..................xx............................................................................................................................................................................................................x
pandas/tests/indexing/test_datetime.py ...........
pandas/tests/indexing/test_floats.py ...............................................................................................................................................
pandas/tests/indexing/test_iat.py .....
pandas/tests/indexing/test_iloc.py ....................................................................................................................................................................................................................
pandas/tests/indexing/test_indexers.py ......
pandas/tests/indexing/test_indexing.py ...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexing/test_loc.py .............................................................................................................................x.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/indexing/test_na_indexing.py ..............................................................................................................................................................................................................................................................................
pandas/tests/indexing/test_partial.py ....................................
pandas/tests/indexing/test_scalar.py ......................................
pandas/tests/indexing/interval/test_interval.py ...........................
pandas/tests/indexing/interval/test_interval_new.py .....................
pandas/tests/indexing/multiindex/test_chaining_and_caching.py ...
pandas/tests/indexing/multiindex/test_datetime.py ..
pandas/tests/indexing/multiindex/test_getitem.py ............................................................................
pandas/tests/indexing/multiindex/test_iloc.py ................
pandas/tests/indexing/multiindex/test_indexing_slow.py ..........
pandas/tests/indexing/multiindex/test_loc.py .................................................................................................................................
pandas/tests/indexing/multiindex/test_multiindex.py ...............
pandas/tests/indexing/multiindex/test_partial.py .............
pandas/tests/indexing/multiindex/test_setitem.py ...........................
pandas/tests/indexing/multiindex/test_slice.py .............................
pandas/tests/indexing/multiindex/test_sorted.py .........
pandas/tests/interchange/test_impl.py ...........................
pandas/tests/interchange/test_spec_conformance.py ................
pandas/tests/interchange/test_utils.py ...............................................
pandas/tests/internals/test_api.py ...
pandas/tests/internals/test_internals.py ....................................................................................................................................................................................................................................................
pandas/tests/internals/test_managers.py ..
pandas/tests/io/test_clipboard.py ........................................................................................................................................................................................................................................xxx.........
pandas/tests/io/test_common.py ..........................................................................................................................................
pandas/tests/io/test_compression.py ........................................................................................................................................
pandas/tests/io/test_feather.py .................
pandas/tests/io/test_fsspec.py ............EEEEEs............
pandas/tests/io/test_gcs.py ..................s
pandas/tests/io/test_html.py ............................................................................................................................................................................s........................
pandas/tests/io/test_orc.py ...................
pandas/tests/io/test_parquet.py ......................................x......................EEEE..............xxxxxx...............E......................
pandas/tests/io/test_pickle.py ..............................................................................................................
pandas/tests/io/test_s3.py .EE
pandas/tests/io/test_spss.py .........
pandas/tests/io/test_sql.py FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF....FFFF...FFFF....FFFF...FFFF...FFFF...FFFFFFFFFFFF.................................................................................................................................ss..............x.....................................................ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.......................
pandas/tests/io/test_stata.py ..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/io/test_user_agent.py ...................
pandas/tests/io/excel/test_odf.py ...
pandas/tests/io/excel/test_odswriter.py ....
pandas/tests/io/excel/test_openpyxl.py ..................................................
pandas/tests/io/excel/test_readers.py ..............................x.......x.....................................xxxxxx............................x.......x...............................................................................x.......x.......x.................................s..s..s.s..s..s.s..s..s.s..s..s.s..s..s.........................ssssssssssssss...................................................xx.xxx.......x.........................................................................................EEEEEEEEEEEEEEEE......................................x.......x.............xx................................x.......x.......................................................................................................................xs......xs..............................................................x.......x.......................................................................................................................x...............xs...sss..
pandas/tests/io/excel/test_style.py ...................................................................................................................................E
pandas/tests/io/excel/test_writers.py ............................xxxx....xxxx....................xxxx.........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/io/excel/test_xlrd.py ......
pandas/tests/io/excel/test_xlsxwriter.py .....
pandas/tests/io/formats/test_console.py ...........
pandas/tests/io/formats/test_css.py ...............................................................................................
pandas/tests/io/formats/test_eng_formatting.py ......
pandas/tests/io/formats/test_format.py .........................................................................................................................................................................................................ssss.ssss...................Out[1]: '<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border="1" class="dataframe">\n  <thead>\n    <tr style="text-align: right;">\n      <th></th>\n      <th>A</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n</div>'
........................................
pandas/tests/io/formats/test_info.py ........................x......<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2 entries, 0 to 1
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   0       2 non-null      int64
 1   1       2 non-null      int64
dtypes: int64(2)
memory usage: 160.0 bytes
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2 entries, 0 to 1
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype
---  ------  --------------  -----
 0   0       2 non-null      int64
 1   1       2 non-null      int64
dtypes: int64(2)
memory usage: 160.0 bytes
.
pandas/tests/io/formats/test_printing.py .............................
pandas/tests/io/formats/test_series_info.py ........x.....
pandas/tests/io/formats/test_to_csv.py ............................................................................................
pandas/tests/io/formats/test_to_excel.py ..........................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/io/formats/test_to_html.py ..........................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/io/formats/test_to_latex.py ...........................................................................................
pandas/tests/io/formats/test_to_markdown.py .........
pandas/tests/io/formats/test_to_string.py .............................................
pandas/tests/io/formats/style/test_bar.py .......................................................................................................................
pandas/tests/io/formats/style/test_exceptions.py ...
pandas/tests/io/formats/style/test_format.py .........................................................................................................
pandas/tests/io/formats/style/test_highlight.py ................................................................................................
pandas/tests/io/formats/style/test_html.py ...........................................................................................
pandas/tests/io/formats/style/test_matplotlib.py ...........................................................
pandas/tests/io/formats/style/test_non_unique.py .........
pandas/tests/io/formats/style/test_style.py .................................................................................................................................................................................................
pandas/tests/io/formats/style/test_to_latex.py ............................................................................................................................................................
pandas/tests/io/formats/style/test_to_string.py .....
pandas/tests/io/formats/style/test_tooltip.py ....
pandas/tests/io/json/test_compression.py ........EEEEEEE...............................................
pandas/tests/io/json/test_deprecated_kwargs.py .
pandas/tests/io/json/test_json_table_schema.py ...........................................................................................x...x...x...x...x...x...x...x...x...x......x...x...x...x...x...x...x...x...x...x.....................
pandas/tests/io/json/test_json_table_schema_ext_dtype.py .....................
pandas/tests/io/json/test_normalize.py .....................................................
pandas/tests/io/json/test_pandas.py ...........................................................................................................xxxx................................xxx.................................................................................................................................................................E........x................................................................xx.............E.....x...........................................
pandas/tests/io/json/test_readlines.py ....x.....xx...x.x.x..............x......xx...x...........
pandas/tests/io/json/test_ujson.py ..................................................................................................................................................................................................................
pandas/tests/io/parser/test_c_parser_only.py .......................................................s..........................
pandas/tests/io/parser/test_comment.py ......ss.......x.sss...s...s...s..................ssssss......ssxx.s
pandas/tests/io/parser/test_compression.py .........sss......ss...s...s.x.x.xss......ss.x.x.xss......ss.x.x.xss......ss.x.x.xss......ss.x.x.xss......ss.x.x.xss......ss..................ssssss......................................................ssssssssssssssssss.........sss...s.......s
pandas/tests/io/parser/test_concatenate_chunks.py ..
pandas/tests/io/parser/test_converters.py ...s............ssss...s...s...s......ss...s...s
pandas/tests/io/parser/test_dialect.py ...s...s...s......................................................ssssssssssssssssss..................ssssss
pandas/tests/io/parser/test_encoding.py .......s..................xxxxxx..........................x.................................................................................................................................................................................................ssssssssssssssssssssssssssssssssssss...s....................xxxxx...x...x......xx
pandas/tests/io/parser/test_header.py ...s.......................s.......s.....................sss.........sss.........sss...s...s...s...s......ss......ss...................s.........sss........................ssssssss...s...s...s...s...s...s...s
pandas/tests/io/parser/test_index_col.py ...................s..............................ssssssssss...s...............sssss...s...s...s.......s...s...s...s...s......x....s
pandas/tests/io/parser/test_mangle_dupes.py ...s...s.............sss.........sss...s...s...s......ss
pandas/tests/io/parser/test_multi_thread.py ...s...s
pandas/tests/io/parser/test_na_values.py ..................................................ssssssssssssss..........ss.......s........................ssss.......s...s......ss......ss...s......ss...s...s.........sss..........ss..........ss..................ssssss...s...s...x........
pandas/tests/io/parser/test_network.py ................ssss.....EEEEEEEEEEFExxEEEE
pandas/tests/io/parser/test_parse_dates.py ...x...x...x......x...............x................x...............x...x...x...xxxxxxxxx......xx......xx......xx.............xxx...x.......................................................x............................xxxx...x...................................x..........................................ssssss.........sss......ss...................x...x............................................................sssssssss...s...s......ss...s...s......s......ss...s..............ss...s....
pandas/tests/io/parser/test_python_parser_only.py .....................................................................................
pandas/tests/io/parser/test_quoting.py .........sss......ss...s..................ssssss............ssss...............sssss......ss......ss......ss
pandas/tests/io/parser/test_read_fwf.py ...............................................................................
pandas/tests/io/parser/test_skiprows.py ......ss...s...s.........sss...s.........sss........xsss...s......ss...s...s...s...s
pandas/tests/io/parser/test_textreader.py ...........................
pandas/tests/io/parser/test_unsupported.py .................x.....
pandas/tests/io/parser/test_upcast.py .............s.................
pandas/tests/io/parser/common/test_chunksize.py ......ss.........sss......ss...s...s......ss...s...s...s...s......ss...s...s...s
pandas/tests/io/parser/common/test_common_basic.py ........x...x....s..x..........xx.........xxx.......x...x...x.......x.........xxx............xxxx......xx..............xx.........sss...x......xx...................................x...x...............xxxxx...x.......x...............................x...x.......x...x....
pandas/tests/io/parser/common/test_data_list.py ...x............
pandas/tests/io/parser/common/test_decimal.py ......xx....
pandas/tests/io/parser/common/test_file_buffer_url.py ...s...s...s...s...s...s.................................sssssssssss...s...s...s...s...s...s...s...s............ssss.....................sssssss...s...s...s...s
pandas/tests/io/parser/common/test_float.py ...s.......s.....................sss....x.....x...ss
pandas/tests/io/parser/common/test_index.py ...................x............xxxx...x.......x...x...x...s...s
pandas/tests/io/parser/common/test_inf.py ......xx......xx....
pandas/tests/io/parser/common/test_ints.py ..............................ss.............sss.........sss......ss......ss....
pandas/tests/io/parser/common/test_iterator.py ...s...s...s.........sss...s
pandas/tests/io/parser/common/test_read_errors.py ...s...s...s.........sss...s..................ssssss...s...s...s...s...s...sxx.s...s...s...s
pandas/tests/io/parser/common/test_verbose.py ...s...s
pandas/tests/io/parser/dtypes/test_categorical.py .........xxx......ss...x...x...x.......x...x...............................................s............................
pandas/tests/io/parser/dtypes/test_dtypes_basic.py ............xxxx...x...x...x...x...................................................................x...x.............................x.x.x...................................................................................................................................................................x.x.x.x.x.x.x.x.x.x.x.x.........................................................................................................................................................................................................................................................................................................................x.x.x.x.x.x.x.x.x.x.x.x...................................................................................................................................................................................................................x......xx...x...x......................................xx...x...x............................
pandas/tests/io/parser/dtypes/test_empty.py ...s...s...s...s...s...s...s...s........................ssssssss
pandas/tests/io/parser/usecols/test_parse_dates.py ......ss...s...s...s............ssss
pandas/tests/io/parser/usecols/test_strings.py ........................
pandas/tests/io/parser/usecols/test_usecols_basic.py ..........ss...s......ss...s...s..........ss............ssss.......s...........s...s......ss...s..........ss......ss......ss.....................sssssss......ss......ss...s...s....
pandas/tests/io/pytables/test_append.py .....................
pandas/tests/io/pytables/test_categorical.py .....
pandas/tests/io/pytables/test_compat.py ....
pandas/tests/io/pytables/test_complex.py .........
pandas/tests/io/pytables/test_errors.py ................
pandas/tests/io/pytables/test_file_handling.py .....................................................................................................................................................................................
pandas/tests/io/pytables/test_keys.py ....
pandas/tests/io/pytables/test_put.py ......................
pandas/tests/io/pytables/test_pytables_missing.py s
pandas/tests/io/pytables/test_read.py ....................
pandas/tests/io/pytables/test_retain_attributes.py ..
pandas/tests/io/pytables/test_round_trip.py ..............................
pandas/tests/io/pytables/test_select.py ........................
pandas/tests/io/pytables/test_store.py ............................................
pandas/tests/io/pytables/test_subclass.py ..
pandas/tests/io/pytables/test_time_series.py ...
pandas/tests/io/pytables/test_timezones.py .......................................................................
pandas/tests/io/sas/test_byteswap.py ..........
pandas/tests/io/sas/test_sas.py ...
pandas/tests/io/sas/test_sas7bdat.py .................................................................................................
pandas/tests/io/sas/test_xport.py ........
pandas/tests/io/xml/test_to_xml.py ......................................................................s...............................................................EE
pandas/tests/io/xml/test_xml.py .....................................................................................s..............................................................................................................................................................E.........
pandas/tests/io/xml/test_xml_dtypes.py ..............................................
pandas/tests/libs/test_hashtable.py ..............s.....................................................................s.............s.......................................................s.............s.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/libs/test_join.py .................
pandas/tests/libs/test_lib.py ..................................................................................
pandas/tests/plotting/test_backend.py .....s.
pandas/tests/plotting/test_boxplot_method.py .......................................................................................
pandas/tests/plotting/test_common.py ...
pandas/tests/plotting/test_converter.py ..[1/1] Generating write_version_file with a custom command
+ /usr/local/bin/ninja
..........................................
pandas/tests/plotting/test_datetimelike.py ...............................................................................................................x.................................................................x...............x.....
pandas/tests/plotting/test_groupby.py .................
pandas/tests/plotting/test_hist_method.py ..................................x..x.............................................................................
pandas/tests/plotting/test_misc.py s................................................
pandas/tests/plotting/test_series.py .......................................XXXX.............................x........................................................................x.........................
pandas/tests/plotting/test_style.py ......................................
pandas/tests/plotting/frame/test_frame.py ....x........................................................................xx..................................................................................................................................................................x...........................................................................................
pandas/tests/plotting/frame/test_frame_color.py ........................................................................................
pandas/tests/plotting/frame/test_frame_groupby.py ......
pandas/tests/plotting/frame/test_frame_legend.py x.....................
pandas/tests/plotting/frame/test_frame_subplots.py .....................x......................XX...................................................................
pandas/tests/plotting/frame/test_hist_box_by.py ......................................................
pandas/tests/reductions/test_reductions.py ...........................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/reductions/test_stat_reductions.py .........................................................................................
pandas/tests/resample/test_base.py ..................................................................................................................x..x..x.....................................xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx......xxx.........................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/resample/test_datetime_index.py ................................................................................ssss.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x......................................................................................................................................................................................................................................................................................................................
pandas/tests/resample/test_period_index.py ...................................................................................................................................................................................................................................................................................................................................................................x.............................................
pandas/tests/resample/test_resample_api.py ...................................................................................................................
pandas/tests/resample/test_resampler_grouper.py ...............................................
pandas/tests/resample/test_time_grouper.py .........................x......................
pandas/tests/resample/test_timedelta.py .......................
pandas/tests/reshape/test_crosstab.py .....................................
pandas/tests/reshape/test_cut.py ............................................................................................................
pandas/tests/reshape/test_from_dummies.py ......................................
pandas/tests/reshape/test_get_dummies.py .......................................................................................................................................................................
pandas/tests/reshape/test_melt.py .....................................................
pandas/tests/reshape/test_pivot.py .....................................................................xx..........................................................................................................................................................................................................................................................................................................................................................................................................................x..x.........................................................
pandas/tests/reshape/test_pivot_multilevel.py ..........
pandas/tests/reshape/test_qcut.py ..........................................................................
pandas/tests/reshape/test_union_categoricals.py ..........................................
pandas/tests/reshape/test_util.py .................
pandas/tests/reshape/concat/test_append.py ..................................................................................
pandas/tests/reshape/concat/test_append_common.py ...........................................................................................
pandas/tests/reshape/concat/test_categorical.py .............
pandas/tests/reshape/concat/test_concat.py .........................................................................................
pandas/tests/reshape/concat/test_dataframe.py .....................
pandas/tests/reshape/concat/test_datetimes.py ................................x.......
pandas/tests/reshape/concat/test_empty.py ........................................................
pandas/tests/reshape/concat/test_index.py .............................................................
pandas/tests/reshape/concat/test_invalid.py ....
pandas/tests/reshape/concat/test_series.py .............
pandas/tests/reshape/concat/test_sort.py ..........
pandas/tests/reshape/merge/test_join.py .......................................................................
pandas/tests/reshape/merge/test_merge.py ...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/reshape/merge/test_merge_asof.py .s..............................................................................................s.............s....................
pandas/tests/reshape/merge/test_merge_cross.py ................
pandas/tests/reshape/merge/test_merge_index_as_string.py ................................................................................
pandas/tests/reshape/merge/test_merge_ordered.py ..................
pandas/tests/reshape/merge/test_multi.py ........................................
pandas/tests/scalar/test_na_scalar.py .....................................................................................ss.....ss.....ss................................................................................................................................................................................
pandas/tests/scalar/test_nat.py ...............................................................................................................................................................................................................................................................................................................................................................
pandas/tests/scalar/interval/test_arithmetic.py .....................
pandas/tests/scalar/interval/test_interval.py ..............................................................................
pandas/tests/scalar/interval/test_ops.py ................................................................................................................................................................................
pandas/tests/scalar/period/test_asfreq.py .......................
pandas/tests/scalar/period/test_period.py ......................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/scalar/timedelta/test_arithmetic.py ................................................................................................................................
pandas/tests/scalar/timedelta/test_constructors.py .................................................................................................................................
pandas/tests/scalar/timedelta/test_formats.py ..........
pandas/tests/scalar/timedelta/test_timedelta.py ..................................................................................................................................................................................................................................................................................
pandas/tests/scalar/timestamp/test_arithmetic.py .......................................................................................................
pandas/tests/scalar/timestamp/test_comparisons.py ..............................
pandas/tests/scalar/timestamp/test_constructors.py ...................xxx................................................................................
pandas/tests/scalar/timestamp/test_formats.py ....................
pandas/tests/scalar/timestamp/test_rendering.py ....................................................
pandas/tests/scalar/timestamp/test_timestamp.py ........................................................................................................................................................x...........................................................................................................................................................................................................................................................................................................................................
pandas/tests/scalar/timestamp/test_timezones.py ...........................................................................................................................................................................................................................................................................................................
pandas/tests/scalar/timestamp/test_unary_ops.py .....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/series/test_api.py ............................................................................................................................................................................................
pandas/tests/series/test_arithmetic.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x................................x..............
pandas/tests/series/test_constructors.py .....................................................................................................................................................................................................................................x.........x..............................................................................................................................xx.............................................................
pandas/tests/series/test_cumulative.py .......................................
pandas/tests/series/test_iteration.py .......
pandas/tests/series/test_logical_ops.py ..........................x
pandas/tests/series/test_missing.py ...x..
pandas/tests/series/test_npfuncs.py ....
pandas/tests/series/test_reductions.py ...................
pandas/tests/series/test_repr.py ...................................................
pandas/tests/series/test_subclass.py .........
pandas/tests/series/test_ufunc.py .....................................................................xxxx........................................................................................................................................
pandas/tests/series/test_unary.py ..........................
pandas/tests/series/test_validate.py ............................
pandas/tests/series/accessors/test_cat_accessor.py ...................
pandas/tests/series/accessors/test_dt_accessor.py ...........................................................................................................................
pandas/tests/series/accessors/test_sparse_accessor.py .
pandas/tests/series/accessors/test_str_accessor.py ..
pandas/tests/series/indexing/test_datetime.py ................
pandas/tests/series/indexing/test_delitem.py ....
pandas/tests/series/indexing/test_get.py ............
pandas/tests/series/indexing/test_getitem.py ..............................................................................................
pandas/tests/series/indexing/test_indexing.py .........................................................................................................
pandas/tests/series/indexing/test_mask.py ....
pandas/tests/series/indexing/test_set_value.py ...
pandas/tests/series/indexing/test_setitem.py ........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x........x........x........x........x........x........x........x........x........x........x........x......................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/series/indexing/test_take.py ....
pandas/tests/series/indexing/test_where.py .........................................................................................................................................................................................................
pandas/tests/series/indexing/test_xs.py ......
pandas/tests/series/methods/test_add_prefix_suffix.py ...
pandas/tests/series/methods/test_align.py ...............................................................................................................
pandas/tests/series/methods/test_argsort.py ....
pandas/tests/series/methods/test_asof.py .......
pandas/tests/series/methods/test_astype.py ................................................................................................................................x........x.........................
pandas/tests/series/methods/test_autocorr.py .
pandas/tests/series/methods/test_between.py .......
pandas/tests/series/methods/test_clip.py ......................................................................
pandas/tests/series/methods/test_combine.py .
pandas/tests/series/methods/test_combine_first.py ...........................
pandas/tests/series/methods/test_compare.py ............
pandas/tests/series/methods/test_convert_dtypes.py .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/series/methods/test_copy.py ..........
pandas/tests/series/methods/test_count.py ...
pandas/tests/series/methods/test_cov_corr.py ................
pandas/tests/series/methods/test_describe.py ......................................................
pandas/tests/series/methods/test_diff.py .......
pandas/tests/series/methods/test_drop.py .............................
pandas/tests/series/methods/test_drop_duplicates.py ..................................................................ssssss.............................................................................................................................................................................................................................................................................................................
pandas/tests/series/methods/test_dropna.py ........
pandas/tests/series/methods/test_dtypes.py .
pandas/tests/series/methods/test_duplicated.py ..................
pandas/tests/series/methods/test_equals.py .....................................................
pandas/tests/series/methods/test_explode.py .................
pandas/tests/series/methods/test_fillna.py ..............................................................................................................................
pandas/tests/series/methods/test_get_numeric_data.py .
pandas/tests/series/methods/test_head_tail.py .
pandas/tests/series/methods/test_infer_objects.py .......
pandas/tests/series/methods/test_interpolate.py x.........................................................................................................................................................................................................x.x............
pandas/tests/series/methods/test_is_monotonic.py ..
pandas/tests/series/methods/test_is_unique.py ........
pandas/tests/series/methods/test_isin.py .........................................
pandas/tests/series/methods/test_isna.py ..
pandas/tests/series/methods/test_item.py .
pandas/tests/series/methods/test_map.py ......................................xxx............................................
pandas/tests/series/methods/test_matmul.py .
pandas/tests/series/methods/test_nlargest.py .................................................................
pandas/tests/series/methods/test_nunique.py ..
pandas/tests/series/methods/test_pct_change.py ............
pandas/tests/series/methods/test_pop.py .
pandas/tests/series/methods/test_quantile.py ...................................
pandas/tests/series/methods/test_rank.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/series/methods/test_reindex.py ...................................
pandas/tests/series/methods/test_reindex_like.py ..
pandas/tests/series/methods/test_rename.py ................
pandas/tests/series/methods/test_rename_axis.py .....
pandas/tests/series/methods/test_repeat.py ...
pandas/tests/series/methods/test_replace.py .....................................................................................................
pandas/tests/series/methods/test_reset_index.py ..............
pandas/tests/series/methods/test_round.py ..................................
pandas/tests/series/methods/test_searchsorted.py ........
pandas/tests/series/methods/test_set_name.py ..
pandas/tests/series/methods/test_size.py .......
pandas/tests/series/methods/test_sort_index.py ............................................
pandas/tests/series/methods/test_sort_values.py ..............
pandas/tests/series/methods/test_to_csv.py ...................................
pandas/tests/series/methods/test_to_dict.py ......
pandas/tests/series/methods/test_to_frame.py ...
pandas/tests/series/methods/test_to_numpy.py ...
pandas/tests/series/methods/test_tolist.py .............
pandas/tests/series/methods/test_truncate.py ....
pandas/tests/series/methods/test_tz_localize.py ...................
pandas/tests/series/methods/test_unique.py .......
pandas/tests/series/methods/test_unstack.py .......
pandas/tests/series/methods/test_update.py ..........................
pandas/tests/series/methods/test_value_counts.py ............
pandas/tests/series/methods/test_values.py ...
pandas/tests/series/methods/test_view.py ..................................................
pandas/tests/strings/test_api.py ................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x.................................................................................................xx............xx......xx....................xx........................xxxx.............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/strings/test_case_justify.py ......................................................................
pandas/tests/strings/test_cat.py ................................................................
pandas/tests/strings/test_extract.py .........................................................................................sss............................................................................................................................sss.....................................................................................
pandas/tests/strings/test_find_replace.py ..............................................................................................................................................................................................................................................
pandas/tests/strings/test_get_dummies.py ........
pandas/tests/strings/test_split_partition.py .......................................................................................................................................................................................
pandas/tests/strings/test_string_array.py ................................................................................................................................................................
pandas/tests/strings/test_strings.py ............................................................................................................................................................................................................................................................
pandas/tests/tools/test_to_datetime.py .................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................xx.....................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/tools/test_to_numeric.py ........................................................................................................................................................................................................................................................xx.........................................................................................................................................................................................
pandas/tests/tools/test_to_time.py ...........
pandas/tests/tools/test_to_timedelta.py .................................................................................
pandas/tests/tseries/frequencies/test_freq_code.py ....................................
pandas/tests/tseries/frequencies/test_frequencies.py ..........
pandas/tests/tseries/frequencies/test_inference.py .................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/tseries/holiday/test_calendar.py ........
pandas/tests/tseries/holiday/test_federal.py ...
pandas/tests/tseries/holiday/test_holiday.py ................................................
pandas/tests/tseries/holiday/test_observance.py .................................
pandas/tests/tseries/offsets/test_business_day.py .......................
pandas/tests/tseries/offsets/test_business_hour.py ................................................................................
pandas/tests/tseries/offsets/test_business_month.py .....................
pandas/tests/tseries/offsets/test_business_quarter.py ..............................................
pandas/tests/tseries/offsets/test_business_year.py ...................
pandas/tests/tseries/offsets/test_common.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/tseries/offsets/test_custom_business_day.py .......
pandas/tests/tseries/offsets/test_custom_business_hour.py ............................
pandas/tests/tseries/offsets/test_custom_business_month.py ......................................................
pandas/tests/tseries/offsets/test_dst.py ..........................
pandas/tests/tseries/offsets/test_easter.py ..........
pandas/tests/tseries/offsets/test_fiscal.py .............................................................................................................................................
pandas/tests/tseries/offsets/test_index.py ........................
pandas/tests/tseries/offsets/test_month.py ............................................................
pandas/tests/tseries/offsets/test_offsets.py .................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................x..................................................................................................................................................................................................................................................x...............................................................................................................................................................................................................................................
pandas/tests/tseries/offsets/test_offsets_properties.py ..
pandas/tests/tseries/offsets/test_quarter.py ........................................................................................
pandas/tests/tseries/offsets/test_ticks.py ...........................................................................................................
pandas/tests/tseries/offsets/test_week.py ..............................................
pandas/tests/tseries/offsets/test_year.py .................................
pandas/tests/tslibs/test_api.py .
pandas/tests/tslibs/test_array_to_datetime.py ...........................
pandas/tests/tslibs/test_ccalendar.py .................
pandas/tests/tslibs/test_conversion.py ......................................................................
pandas/tests/tslibs/test_fields.py ....
pandas/tests/tslibs/test_libfrequencies.py ..............
pandas/tests/tslibs/test_liboffsets.py ..........................................................................
pandas/tests/tslibs/test_np_datetime.py ........
pandas/tests/tslibs/test_parse_iso8601.py ...................................................
pandas/tests/tslibs/test_parsing.py ...........................................................................................................................
pandas/tests/tslibs/test_period_asfreq.py ......................................
pandas/tests/tslibs/test_resolution.py ..
pandas/tests/tslibs/test_timedeltas.py .........................
pandas/tests/tslibs/test_timezones.py .........................................................................................................................................................................................................................................................................................................................................................s..............................................................s................................................................................
pandas/tests/tslibs/test_to_offset.py ...................................................................................
pandas/tests/tslibs/test_tzconversion.py .
pandas/tests/util/test_assert_almost_equal.py ....................................................................................................................................................................
pandas/tests/util/test_assert_attr_equal.py ..........................................
pandas/tests/util/test_assert_categorical_equal.py ..........
pandas/tests/util/test_assert_extension_array_equal.py ....................
pandas/tests/util/test_assert_frame_equal.py ...............................................................................................................
pandas/tests/util/test_assert_index_equal.py ................................................................
pandas/tests/util/test_assert_interval_array_equal.py .......
pandas/tests/util/test_assert_numpy_array_equal.py .........................
pandas/tests/util/test_assert_produces_warning.py ............................................................................................................................
pandas/tests/util/test_assert_series_equal.py ..................................................................................
pandas/tests/util/test_deprecate.py ...
pandas/tests/util/test_deprecate_kwarg.py ..............
pandas/tests/util/test_deprecate_nonkeyword_arguments.py ...................
pandas/tests/util/test_doc.py ....
pandas/tests/util/test_hashing.py .....................................................................................................................................................
pandas/tests/util/test_make_objects.py .
pandas/tests/util/test_numba.py s
pandas/tests/util/test_rewrite_warning.py ..........
pandas/tests/util/test_safe_import.py ........
pandas/tests/util/test_shares_memory.py .
pandas/tests/util/test_show_versions.py ....
pandas/tests/util/test_util.py ......s..
pandas/tests/util/test_validate_args.py ......
pandas/tests/util/test_validate_args_and_kwargs.py ......
pandas/tests/util/test_validate_inclusive.py ...........
pandas/tests/util/test_validate_kwargs.py ..................
pandas/tests/window/test_api.py .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_apply.py ..................................................................................
pandas/tests/window/test_base_indexer.py ..................................................................................................................................................................................................................................
pandas/tests/window/test_cython_aggregations.py ........................................................................
pandas/tests/window/test_dtypes.py ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_ewm.py ..................................................................................................................................................................................................................................
pandas/tests/window/test_expanding.py ..........x..................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_groupby.py ........................................................................................................
pandas/tests/window/test_numba.py ...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_online.py .................xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....
pandas/tests/window/test_pairwise.py .......................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_rolling.py ...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_rolling_functions.py ..................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/test_rolling_quantile.py ..........................................................................................................................................................................................
pandas/tests/window/test_rolling_skew_kurt.py ......................................................................
pandas/tests/window/test_timeseries_window.py .........................................................................
pandas/tests/window/test_win_type.py ...............................................................................................................................................................................................................................................................................................
pandas/tests/window/moments/test_moments_consistency_ewm.py ................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
pandas/tests/window/moments/test_moments_consistency_expanding.py ........x.......................x..x..x..x..x..x....................x.......................x..x..x..x..x..x................................................................................................................................................................................................................................................................................
pandas/tests/window/moments/test_moments_consistency_rolling.py ..............x..x............................................x..x..x..x..x..x..x..x..x..x..x..x......................................x..x............................................x..x..x..x..x..x..x..x..x..x..x..x................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................

==================================== ERRORS ====================================
______________________ ERROR at setup of test_from_s3_csv ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71b9d9bf70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71bae892a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fd0878b5-8601-4fe7-a103-971...nvocation-id': b'95c0e9db-1685-4d1c-a5fc-0fb6037e771e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71b9d9bf70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71b9d9bf70>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71bae892a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-fd0878b5-8601-4fe7-a103-971...nvocation-id': b'95c0e9db-1685-4d1c-a5fc-0fb6037e771e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-fd0878b5-8601-4fe7-a103-971ab3751aca"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86eae90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e1f130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c3e86e72-20fe-48eb-9a77-c6c...nvocation-id': b'7efcad9a-6d18-4fd0-8649-a85e0a5b0cba', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86eae90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86eae90>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e1f130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c3e86e72-20fe-48eb-9a77-c6c...nvocation-id': b'7efcad9a-6d18-4fd0-8649-a85e0a5b0cba', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c3e86e72-20fe-48eb-9a77-c6c056e58aba"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3a] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86c4bb0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3ea2ad0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-421a48b0-d27c-4528-afda-525...nvocation-id': b'b33f4729-779d-48ed-ac8e-7e119c12b5ed', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86c4bb0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c86c4bb0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3ea2ad0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-421a48b0-d27c-4528-afda-525...nvocation-id': b'b33f4729-779d-48ed-ac8e-7e119c12b5ed', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-421a48b0-d27c-4528-afda-52589dc0a665"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_s3_protocols[s3n] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3fb87c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e61840>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f555e681-3f5b-4bf2-ad5d-310...nvocation-id': b'73499bf1-71ad-414e-b789-a08e355e6b14', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3fb87c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3fb87c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e61840>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f555e681-3f5b-4bf2-ad5d-310...nvocation-id': b'73499bf1-71ad-414e-b789-a08e355e6b14', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-f555e681-3f5b-4bf2-ad5d-310e83e1bbda"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________________ ERROR at setup of test_s3_parquet _______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8750670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71bb5c3d30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b396ebec-2a8c-4f68-adef-ada...nvocation-id': b'314ac9b3-1016-490f-84ac-3d698635c2b9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8750670>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8750670>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71bb5c3d30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b396ebec-2a8c-4f68-adef-ada...nvocation-id': b'314ac9b3-1016-490f-84ac-3d698635c2b9', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-b396ebec-2a8c-4f68-adef-ada359d90edf"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_explicit_fs ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193374160>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7193c696c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-59268cba-4580-4b41-a7ad-381...nvocation-id': b'08a9b890-cd8f-4a05-9590-e6a3953f93bc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193374160>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193374160>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7193c696c0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-59268cba-4580-4b41-a7ad-381...nvocation-id': b'08a9b890-cd8f-4a05-9590-e6a3953f93bc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-59268cba-4580-4b41-a7ad-3818ce2016ee"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193380c70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192e60580>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1a513fc1-0786-4c51-8289-4c9...nvocation-id': b'321c5c8f-0801-4e68-8e0f-31defd378bfe', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193380c70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193380c70>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192e60580>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1a513fc1-0786-4c51-8289-4c9...nvocation-id': b'321c5c8f-0801-4e68-8e0f-31defd378bfe', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1a513fc1-0786-4c51-8289-4c9112a5ce53"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col0] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cc99f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192af7f10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f0070ccb-a588-4dda-9729-f83...nvocation-id': b'45ff49e3-5b2b-495d-a2a4-48420cf08954', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cc99f0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cc99f0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192af7f10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-f0070ccb-a588-4dda-9729-f83...nvocation-id': b'45ff49e3-5b2b-495d-a2a4-48420cf08954', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-f0070ccb-a588-4dda-9729-f837219f9d08"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestParquetPyArrow.test_s3_roundtrip_for_dir[partition_col1] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193065750>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192c21ff0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a7869a23-bf71-496a-9d86-80a...nvocation-id': b'a1861e24-e4ef-4692-a755-cae25abdabc6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193065750>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193065750>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192c21ff0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a7869a23-bf71-496a-9d86-80a...nvocation-id': b'a1861e24-e4ef-4692-a755-cae25abdabc6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-a7869a23-bf71-496a-9d86-80ac757e83a3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestParquetFastParquet.test_s3_roundtrip __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192b6d240>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192eb0130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-221e2135-3b78-44ca-9f33-7c5...nvocation-id': b'4e9f034b-b0c1-40bb-a033-7d057a0b3741', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192b6d240>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192b6d240>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192eb0130>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-221e2135-3b78-44ca-9f33-7c5...nvocation-id': b'4e9f034b-b0c1-40bb-a033-7d057a0b3741', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-221e2135-3b78-44ca-9f33-7c55cb474540"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of test_read_without_creds_from_pub_bucket ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cb0880>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71931f39d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2048b66e-fb2f-45b8-a53b-b05...nvocation-id': b'af95e1c2-1196-4cb2-8348-f30abaf70191', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cb0880>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192cb0880>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71931f39d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2048b66e-fb2f-45b8-a53b-b05...nvocation-id': b'af95e1c2-1196-4cb2-8348-f30abaf70191', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-2048b66e-fb2f-45b8-a53b-b05db24f8e60"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of test_read_with_creds_from_pub_bucket ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a6b640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192becaf0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-587577d2-a134-4a38-8fef-fc8...nvocation-id': b'31dedf5c-fef3-4897-b2b6-b196d3beae81', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a6b640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a6b640>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192becaf0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-587577d2-a134-4a38-8fef-fc8...nvocation-id': b'31dedf5c-fef3-4897-b2b6-b196d3beae81', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-587577d2-a134-4a38-8fef-fc87265002d3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_url[('xlrd', '.xls')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca24aa70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb843610>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ed377fab-6fdc-45bc-9c83-27f...nvocation-id': b'adfc42d6-32c8-497a-874b-1cdaed6d0b5f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca24aa70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca24aa70>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb843610>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ed377fab-6fdc-45bc-9c83-27f...nvocation-id': b'adfc42d6-32c8-497a-874b-1cdaed6d0b5f', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ed377fab-6fdc-45bc-9c83-27f3b425f984"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsx')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbb18b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cad121d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-faae55c3-bf72-4c0a-938c-106...nvocation-id': b'cd313583-ab76-4e10-af16-288e94eae10e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbb18b20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbb18b20>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cad121d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-faae55c3-bf72-4c0a-938c-106...nvocation-id': b'cd313583-ab76-4e10-af16-288e94eae10e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-faae55c3-bf72-4c0a-938c-106b91d74be4"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__ ERROR at setup of TestReaders.test_read_from_s3_url[('openpyxl', '.xlsm')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbf0ca90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71988f1fc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d832ec9b-ef35-49f5-ba2f-406...nvocation-id': b'a8b12564-0221-4861-a3d6-12aeac8b2089', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbf0ca90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbf0ca90>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71988f1fc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d832ec9b-ef35-49f5-ba2f-406...nvocation-id': b'a8b12564-0221-4861-a3d6-12aeac8b2089', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d832ec9b-ef35-49f5-ba2f-406e55e508b9"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xls')] ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3d8a30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d00ff970>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d769ee5d-c079-4a1b-944b-6e7...nvocation-id': b'7f8f2e2f-3fbb-44e5-bd61-eff004480615', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3d8a30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3d8a30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d00ff970>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d769ee5d-c079-4a1b-944b-6e7...nvocation-id': b'7f8f2e2f-3fbb-44e5-bd61-eff004480615', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d769ee5d-c079-4a1b-944b-6e72f356e003"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsx')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cba6fb80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71ca5eca00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-77dc5b89-0fb1-4e5e-ae02-c47...nvocation-id': b'243a56e8-c84a-455d-92d4-4390de5a1628', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cba6fb80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cba6fb80>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71ca5eca00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-77dc5b89-0fb1-4e5e-ae02-c47...nvocation-id': b'243a56e8-c84a-455d-92d4-4390de5a1628', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-77dc5b89-0fb1-4e5e-ae02-c473ba48abfa"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[(None, '.xlsm')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192c118d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7193fe82b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dc42ed89-d7e3-421d-88ca-3dd...nvocation-id': b'4b7fdf5a-451c-4adf-8d02-5f7f25cc6fee', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192c118d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192c118d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7193fe82b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-dc42ed89-d7e3-421d-88ca-3dd...nvocation-id': b'4b7fdf5a-451c-4adf-8d02-5f7f25cc6fee', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-dc42ed89-d7e3-421d-88ca-3dd722663a9b"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_url[('pyxlsb', '.xlsb')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cabf9390>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb167ca0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7721c943-1a86-43fc-bf90-52d...nvocation-id': b'37b46fc2-5233-4660-95e5-441a2950ebf2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cabf9390>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cabf9390>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb167ca0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7721c943-1a86-43fc-bf90-52d...nvocation-id': b'37b46fc2-5233-4660-95e5-441a2950ebf2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-7721c943-1a86-43fc-bf90-52d24d149b9b"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestReaders.test_read_from_s3_url[('odf', '.ods')] _____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064de10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb758ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-238cc42c-c48f-4a7b-a07f-d35...nvocation-id': b'bf13d300-f436-47ec-be85-673bc14414e0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064de10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064de10>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb758ee0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-238cc42c-c48f-4a7b-a07f-d35...nvocation-id': b'bf13d300-f436-47ec-be85-673bc14414e0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-238cc42c-c48f-4a7b-a07f-d358bfd5e043"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('xlrd', '.xls')] ___

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3da5c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbf1cb20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b1b8abe6-729d-4783-a408-fed...nvocation-id': b'fc1e84f0-4fb3-466c-a964-a7b44ccfd6c0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3da5c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb3da5c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbf1cb20>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-b1b8abe6-729d-4783-a408-fed...nvocation-id': b'fc1e84f0-4fb3-466c-a964-a7b44ccfd6c0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-b1b8abe6-729d-4783-a408-fedf85be99bf"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsx')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbd92860>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9c1ead0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9b63b759-7c1a-4dee-8ca9-b35...nvocation-id': b'afd74238-ffe8-4885-b269-1be466884a08', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbd92860>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbd92860>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9c1ead0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9b63b759-7c1a-4dee-8ca9-b35...nvocation-id': b'afd74238-ffe8-4885-b269-1be466884a08', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9b63b759-7c1a-4dee-8ca9-b35d8b23bd2c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('openpyxl', '.xlsm')] _

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193fb7fa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f719905c3a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d402f965-499b-48f0-88e0-9ad...nvocation-id': b'f057540b-229e-4669-bd45-620a5e8f2486', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193fb7fa0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7193fb7fa0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f719905c3a0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d402f965-499b-48f0-88e0-9ad...nvocation-id': b'f057540b-229e-4669-bd45-620a5e8f2486', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d402f965-499b-48f0-88e0-9adb12ae456a"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xls')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb59d5d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71982554e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ac18e393-5755-44af-a058-e89...nvocation-id': b'1ac8fce6-ffc6-41d9-a0f5-167b7ed29800', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb59d5d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb59d5d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71982554e0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ac18e393-5755-44af-a058-e89...nvocation-id': b'1ac8fce6-ffc6-41d9-a0f5-167b7ed29800', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ac18e393-5755-44af-a058-e89bb69280b2"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsx')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d05fcc40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cadd3a00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1db2e462-624a-45f0-a027-bdc...nvocation-id': b'd906c2cc-ce15-44f1-8429-07f666e2c460', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d05fcc40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d05fcc40>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cadd3a00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-1db2e462-624a-45f0-a027-bdc...nvocation-id': b'd906c2cc-ce15-44f1-8429-07f666e2c460', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-1db2e462-624a-45f0-a027-bdc2421a4308"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[(None, '.xlsm')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbcdf130>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192c96d70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-99ac8131-805f-49e2-906b-5c6...nvocation-id': b'5326d734-2d46-4f0c-8e68-328355d72837', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbcdf130>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbcdf130>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192c96d70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-99ac8131-805f-49e2-906b-5c6...nvocation-id': b'5326d734-2d46-4f0c-8e68-328355d72837', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-99ac8131-805f-49e2-906b-5c6ffb201c6d"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_ ERROR at setup of TestReaders.test_read_from_s3_object[('pyxlsb', '.xlsb')] __

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9ed10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7192ff0bb0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6ceba9cf-622f-4ae1-a646-8d0...nvocation-id': b'febfe307-b2c7-4bbc-912d-0accbf1a697a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9ed10>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9ed10>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7192ff0bb0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-6ceba9cf-622f-4ae1-a646-8d0...nvocation-id': b'febfe307-b2c7-4bbc-912d-0accbf1a697a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-6ceba9cf-622f-4ae1-a646-8d053f50b631"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___ ERROR at setup of TestReaders.test_read_from_s3_object[('odf', '.ods')] ____

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064cd30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9aa49d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0df38cb9-0b0c-43bd-b7cc-d44...nvocation-id': b'a458b4f9-ed7f-4c2e-8eff-8f8043a6c1f2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064cd30>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d064cd30>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

/workspace/pandas/pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9aa49d0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0df38cb9-0b0c-43bd-b7cc-d44...nvocation-id': b'a458b4f9-ed7f-4c2e-8eff-8f8043a6c1f2', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0df38cb9-0b0c-43bd-b7cc-d44f9e68862f"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________________ ERROR at setup of test_styler_to_s3 ______________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb2b9d80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0ffdc30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4f4a5325-8fd5-453d-9863-ca8...nvocation-id': b'7d84d8aa-99dd-4cd5-a480-2add3990492e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb2b9d80>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb2b9d80>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0ffdc30>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4f4a5325-8fd5-453d-9863-ca8...nvocation-id': b'7d84d8aa-99dd-4cd5-a480-2add3990492e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-4f4a5325-8fd5-453d-9863-ca8e9bc6bdfa"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[None] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8aff1c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e611b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9bd64894-720c-48f2-9ac3-564...nvocation-id': b'bc66dac5-6460-41bf-93df-39f1de14d609', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8aff1c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8aff1c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3e611b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-9bd64894-720c-48f2-9ac3-564...nvocation-id': b'bc66dac5-6460-41bf-93df-39f1de14d609', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-9bd64894-720c-48f2-9ac3-564cf3ccb269"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[gzip] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8125270>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c0814a00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-43656bd4-ec0a-4a89-b104-cc9...nvocation-id': b'80a096aa-9c1d-4586-8732-acc3e14ce729', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8125270>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8125270>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c0814a00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-43656bd4-ec0a-4a89-b104-cc9...nvocation-id': b'80a096aa-9c1d-4586-8732-acc3e14ce729', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-43656bd4-ec0a-4a89-b104-cc9b077387ee"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[bz2] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f30340>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c23d7280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3f3b0a4f-38fe-4509-804a-b00...nvocation-id': b'a6493881-fc19-4ba8-9002-727f8c18cf79', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f30340>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f30340>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c23d7280>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-3f3b0a4f-38fe-4509-804a-b00...nvocation-id': b'a6493881-fc19-4ba8-9002-727f8c18cf79', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-3f3b0a4f-38fe-4509-804a-b00bb769b556"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zip] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3f7a260>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c017c970>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8f6c5a82-095a-43ef-af3b-bca...nvocation-id': b'08d03377-84e8-4eef-8580-293899708033', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3f7a260>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3f7a260>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c017c970>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8f6c5a82-095a-43ef-af3b-bca...nvocation-id': b'08d03377-84e8-4eef-8580-293899708033', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-8f6c5a82-095a-43ef-af3b-bca92edd53f2"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________________ ERROR at setup of test_with_s3_url[xz] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8270220>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c24b9ae0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-92f5caca-dccd-4057-9ad0-c39...nvocation-id': b'28405380-0b9d-45a7-b2ea-65ea480fca07', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8270220>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c8270220>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c24b9ae0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-92f5caca-dccd-4057-9ad0-c39...nvocation-id': b'28405380-0b9d-45a7-b2ea-65ea480fca07', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-92f5caca-dccd-4057-9ad0-c39c10c4d614"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[tar] ____________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbe180a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3176e00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-51c2c3f5-ec47-4631-b60a-ae8...nvocation-id': b'77047111-e899-44e7-811b-dc6e2a84065d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbe180a0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cbe180a0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c3176e00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-51c2c3f5-ec47-4631-b60a-ae8...nvocation-id': b'77047111-e899-44e7-811b-dc6e2a84065d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-51c2c3f5-ec47-4631-b60a-ae86f8119873"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________________ ERROR at setup of test_with_s3_url[zstd] ___________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3dc0310>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8e5a6b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c0ba4caf-f390-49e0-a0e2-318...nvocation-id': b'9a4e8c9e-c9ae-4326-a448-3fc3e8983363', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3dc0310>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c3dc0310>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8e5a6b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c0ba4caf-f390-49e0-a0e2-318...nvocation-id': b'9a4e8c9e-c9ae-4326-a448-3fc3e8983363', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c0ba4caf-f390-49e0-a0e2-318ba2f55f77"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestPandasContainer.test_read_s3_jsonl ___________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d018cb20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0b7e800>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-300b4908-5404-45ed-bb9a-802...nvocation-id': b'29d2ac1e-553e-4ea0-9fb8-1774b3b8c3d6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d018cb20>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d018cb20>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0b7e800>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-300b4908-5404-45ed-bb9a-802...nvocation-id': b'29d2ac1e-553e-4ea0-9fb8-1774b3b8c3d6', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-300b4908-5404-45ed-bb9a-802d8ab4c7a3"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_______________ ERROR at setup of TestPandasContainer.test_to_s3 _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9191f90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c0ea4790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-48995b71-a429-4914-b81d-124...nvocation-id': b'2135826d-fe38-4d28-a236-5166f30d75cb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9191f90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9191f90>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c0ea4790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-48995b71-a429-4914-b81d-124...nvocation-id': b'2135826d-fe38-4d28-a236-5166f30d75cb', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-48995b71-a429-4914-b81d-1245de582a66"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________ ERROR at setup of TestS3.test_parse_public_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d00431c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f7193cd60b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-23941ec7-2532-4ed6-808d-a15...nvocation-id': b'e572d484-8ff3-4fe4-bba2-ee5d5e0d2ff4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d00431c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d00431c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f7193cd60b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-23941ec7-2532-4ed6-808d-a15...nvocation-id': b'e572d484-8ff3-4fe4-bba2-ee5d5e0d2ff4', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-23941ec7-2532-4ed6-808d-a15ac8e2d007"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_private_s3_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e06a5e70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c907cd00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-184473bc-6f1d-46a8-b9e3-3cc...nvocation-id': b'3b74c2cc-9fb6-451a-a56f-dd9337191c09', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e06a5e70>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e06a5e70>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c907cd00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-184473bc-6f1d-46a8-b9e3-3cc...nvocation-id': b'3b74c2cc-9fb6-451a-a56f-dd9337191c09', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-184473bc-6f1d-46a8-b9e3-3cc95b8ff20e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3n_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e02c7190>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c2fc3c40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-45b8cbb5-d5c4-4688-9fb6-02f...nvocation-id': b'db56cfde-f4a9-44ee-9f93-64822e81f74e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e02c7190>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e02c7190>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c2fc3c40>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-45b8cbb5-d5c4-4688-9fb6-02f...nvocation-id': b'db56cfde-f4a9-44ee-9f93-64822e81f74e', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-45b8cbb5-d5c4-4688-9fb6-02f832519369"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_parse_public_s3a_bucket _____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e09a9090>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71e017a5f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8a3dab2d-9ff2-44d7-8b68-aa3...nvocation-id': b'103c1c80-dcd9-48cc-bc77-7976b9b49d9a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e09a9090>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e09a9090>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71e017a5f0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-8a3dab2d-9ff2-44d7-8b68-aa3...nvocation-id': b'103c1c80-dcd9-48cc-bc77-7976b9b49d9a', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-8a3dab2d-9ff2-44d7-8b68-aa30b33a55f5"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
__________ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb419f90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbb9fc10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ab0f4949-d5f9-40f1-bdc1-dcb...nvocation-id': b'97a7c80f-5636-4a51-8739-f6cafe97deb1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb419f90>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb419f90>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbb9fc10>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-ab0f4949-d5f9-40f1-bdc1-dcb...nvocation-id': b'97a7c80f-5636-4a51-8739-f6cafe97deb1', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-ab0f4949-d5f9-40f1-bdc1-dcb87ab3112e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca333a60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d05ce350>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7e106ed3-8b0c-46e3-a0d9-752...nvocation-id': b'ca5bd86e-98e0-44ef-905c-afdc2b4fbf1d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca333a60>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71ca333a60>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d05ce350>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-7e106ed3-8b0c-46e3-a0d9-752...nvocation-id': b'ca5bd86e-98e0-44ef-905c-afdc2b4fbf1d', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-7e106ed3-8b0c-46e3-a0d9-7520e3be2d2b"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____ ERROR at setup of TestS3.test_parse_public_s3_bucket_chunked_python ______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9c6d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71ca3aaa70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-49a27264-464e-46b2-a135-586...nvocation-id': b'aa1e7861-e85f-479b-967a-661ec90437b3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9c6d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c9f9c6d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71ca3aaa70>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-49a27264-464e-46b2-a135-586...nvocation-id': b'aa1e7861-e85f-479b-967a-661ec90437b3', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-49a27264-464e-46b2-a135-586daf55f801"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________ ERROR at setup of TestS3.test_parse_public_s3_bucket_python __________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c98469e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0470d00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-25a1ee5d-f196-4ede-8cd3-e33...nvocation-id': b'6cdf3ebf-3326-4a7b-bdd8-16e68f8dcbd0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c98469e0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c98469e0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0470d00>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-25a1ee5d-f196-4ede-8cd3-e33...nvocation-id': b'6cdf3ebf-3326-4a7b-bdd8-16e68f8dcbd0', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-25a1ee5d-f196-4ede-8cd3-e33d1b477545"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of TestS3.test_infer_s3_compression ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e0631180>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbdc6860>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-401841ec-5c33-47b2-8d43-9d2...nvocation-id': b'38ba3417-f74a-40ee-a911-0f5c4c3accf8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e0631180>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e0631180>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cbdc6860>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-401841ec-5c33-47b2-8d43-9d2...nvocation-id': b'38ba3417-f74a-40ee-a911-0f5c4c3accf8', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-401841ec-5c33-47b2-8d43-9d2231e5ab92"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______ ERROR at setup of TestS3.test_parse_public_s3_bucket_nrows_python _______

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d154de40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9847040>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4c210790-b547-45f7-8bb0-5dd...nvocation-id': b'7a51c4b6-963f-4538-9211-b21e1ef73c55', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d154de40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d154de40>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9847040>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-4c210790-b547-45f7-8bb0-5dd...nvocation-id': b'7a51c4b6-963f-4538-9211-b21e1ef73c55', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-4c210790-b547-45f7-8bb0-5ddf311b9d08"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_____________ ERROR at setup of TestS3.test_read_s3_fails_private ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb75afe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9354340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-1cc10086-5270-4380-8677-263...nvocation-id': b'538b35be-639d-4cf6-a0b4-60918bd76c00', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb75afe0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb75afe0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_private_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"cant_get_it-{uuid.uuid4()}")
>       bucket.create(ACL="private")

pandas/tests/io/conftest.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c9354340>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/cant_get_it-1cc10086-5270-4380-8677-263...nvocation-id': b'538b35be-639d-4cf6-a0b4-60918bd76c00', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/cant_get_it-1cc10086-5270-4380-8677-263d4e21019e"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
________ ERROR at setup of TestS3.test_read_csv_handles_boto_s3_object _________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb4100d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71eaf4dcc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c1afd7ce-5030-4fd8-b5be-762...nvocation-id': b'2d5d08af-3a79-44e8-8e9c-111a9a20c954', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb4100d0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb4100d0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71eaf4dcc0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c1afd7ce-5030-4fd8-b5be-762...nvocation-id': b'2d5d08af-3a79-44e8-8e9c-111a9a20c954', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c1afd7ce-5030-4fd8-b5be-7621922d77fe"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_csv_chunked_download ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e8f9e350>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8c8a440>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a2857ed9-2bf1-4bfe-a5a3-57e...nvocation-id': b'a49d67ac-f19f-415f-8d3b-ffbd485776ca', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e8f9e350>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71e8f9e350>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8c8a440>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-a2857ed9-2bf1-4bfe-a5a3-57e...nvocation-id': b'a49d67ac-f19f-415f-8d3b-ffbd485776ca', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-a2857ed9-2bf1-4bfe-a5a3-57ecc713aa9b"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
____________ ERROR at setup of TestS3.test_read_s3_with_hash_in_key ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb95ea40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0d30670>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0f2935a9-f64c-4689-81fb-943...nvocation-id': b'c62d087e-3439-46f0-b92d-51e47e68ceef', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb95ea40>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71cb95ea40>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0d30670>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-0f2935a9-f64c-4689-81fb-943...nvocation-id': b'c62d087e-3439-46f0-b92d-51e47e68ceef', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-0f2935a9-f64c-4689-81fb-9438ea6ec037"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
___________ ERROR at setup of TestS3.test_read_feather_s3_file_path ____________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a9c4c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0a77820>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d64b9803-0471-4de5-a4ad-dda...nvocation-id': b'46e1c0b8-14a4-44dc-9add-cad2df71bbae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a9c4c0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f7192a9c4c0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71d0a77820>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-d64b9803-0471-4de5-a4ad-dda...nvocation-id': b'46e1c0b8-14a4-44dc-9add-cad2df71bbae', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-d64b9803-0471-4de5-a4ad-ddaeff84901c"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[lxml] _______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f24640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb567790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c084ea66-6376-4b2e-bf64-98c...nvocation-id': b'1ae7c995-108b-4dd4-b63a-6c0b06e08a00', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f24640>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c2f24640>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cb567790>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-c084ea66-6376-4b2e-bf64-98c...nvocation-id': b'1ae7c995-108b-4dd4-b63a-6c0b06e08a00', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-c084ea66-6376-4b2e-bf64-98cfd65e8781"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
______________ ERROR at setup of test_s3_permission_output[etree] ______________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d0cab820>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71cad554b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2d1de81d-05d0-436f-afc3-29a...nvocation-id': b'4be3c0fa-bca9-4d72-a814-52683b9c74fc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d0cab820>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71d0cab820>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71cad554b0>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-2d1de81d-05d0-436f-afc3-29a...nvocation-id': b'4be3c0fa-bca9-4d72-a814-52683b9c74fc', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-2d1de81d-05d0-436f-afc3-29a563a79d67"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
_________________ ERROR at setup of test_s3_parser_consistency _________________

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c89e88b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
>           conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:95: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('127.0.0.1', 5555), timeout = 60, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            return six.raise_from(
                LocationParseError(u"'%s', label empty or too long" % host), None
            )
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/util/connection.py:85: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8d8bb50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-76c3ef2b-8044-46d8-8752-ab5...nvocation-id': b'effadb73-dbfd-41d5-89e1-45149287c823', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
>           urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:798: in urlopen
    retries = retries.increment(
/usr/local/lib/python3.10/site-packages/urllib3/util/retry.py:525: in increment
    raise six.reraise(type(error), error, _stacktrace)
/usr/local/lib/python3.10/site-packages/urllib3/packages/six.py:770: in reraise
    raise value
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:714: in urlopen
    httplib_response = self._make_request(
/usr/local/lib/python3.10/site-packages/urllib3/connectionpool.py:415: in _make_request
    conn.request(method, url, **httplib_request_kw)
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:244: in request
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)
/usr/local/lib/python3.10/http/client.py:1282: in request
    self._send_request(method, url, body, headers, encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:94: in _send_request
    rval = super()._send_request(
/usr/local/lib/python3.10/http/client.py:1328: in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/http/client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:123: in _send_output
    self.send(msg)
/usr/local/lib/python3.10/site-packages/botocore/awsrequest.py:218: in send
    return super().send(str)
/usr/local/lib/python3.10/http/client.py:975: in send
    self.connect()
/usr/local/lib/python3.10/site-packages/urllib3/connection.py:205: in connect
    conn = self._new_conn()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c89e88b0>

    def _new_conn(self):
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        extra_kw = {}
        if self.source_address:
            extra_kw["source_address"] = self.source_address
    
        if self.socket_options:
            extra_kw["socket_options"] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                "Connection to %s timed out. (connect timeout=%s)"
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
>           raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e
            )
E           urllib3.exceptions.NewConnectionError: <botocore.awsrequest.AWSHTTPConnection object at 0x7f71c89e88b0>: Failed to establish a new connection: [Errno 111] Connection refused

/usr/local/lib/python3.10/site-packages/urllib3/connection.py:186: NewConnectionError

During handling of the above exception, another exception occurred:

s3_resource = s3.ServiceResource()

    @pytest.fixture
    def s3_public_bucket(s3_resource):
        bucket = s3_resource.Bucket(f"pandas-test-{uuid.uuid4()}")
>       bucket.create()

pandas/tests/io/conftest.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/boto3/resources/factory.py:580: in do_action
    response = action(self, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/boto3/resources/action.py:88: in __call__
    response = getattr(parent.meta.client, operation_name)(*args, **params)
/usr/local/lib/python3.10/site-packages/botocore/client.py:530: in _api_call
    return self._make_api_call(operation_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/client.py:947: in _make_api_call
    http, parsed_response = self._make_request(
/usr/local/lib/python3.10/site-packages/botocore/client.py:970: in _make_request
    return self._endpoint.make_request(operation_model, request_dict)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:119: in make_request
    return self._send_request(request_dict, operation_model)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:202: in _send_request
    while self._needs_retry(
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:354: in _needs_retry
    responses = self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:412: in emit
    return self._emitter.emit(aliased_event_name, **kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:256: in emit
    return self._emit(event_name, kwargs)
/usr/local/lib/python3.10/site-packages/botocore/hooks.py:239: in _emit
    response = handler(**kwargs)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:207: in __call__
    if self._checker(**checker_kwargs):
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:284: in __call__
    should_retry = self._should_retry(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:320: in _should_retry
    return self._checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:363: in __call__
    checker_response = checker(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:281: in _do_get_response
    http_response = self._send(request)
/usr/local/lib/python3.10/site-packages/botocore/endpoint.py:377: in _send
    return self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <botocore.httpsession.URLLib3Session object at 0x7f71c8d8bb50>
request = <AWSPreparedRequest stream_output=False, method=PUT, url=http://127.0.0.1:5555/pandas-test-76c3ef2b-8044-46d8-8752-ab5...nvocation-id': b'effadb73-dbfd-41d5-89e1-45149287c823', 'amz-sdk-request': b'attempt=5; max=5', 'Content-Length': '0'}>

    def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            manager = self._get_connection_manager(request.url, proxy_url)
            conn = manager.connection_from_url(request.url)
            self._setup_ssl_cert(conn, request.url, self._verify)
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                conn.proxy_headers['host'] = host
    
            request_target = self._get_request_target(request.url, proxy_url)
            urllib_response = conn.urlopen(
                method=request.method,
                url=request_target,
                body=request.body,
                headers=request.headers,
                retries=Retry(False),
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                chunked=self._chunked(request.headers),
            )
    
            http_response = botocore.awsrequest.AWSResponse(
                request.url,
                urllib_response.status,
                urllib_response.headers,
                urllib_response,
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                http_response.content
    
            return http_response
        except URLLib3SSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (NewConnectionError, socket.gaierror) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/pandas-test-76c3ef2b-8044-46d8-8752-ab5c1ee70685"

/usr/local/lib/python3.10/site-packages/botocore/httpsession.py:494: EndpointConnectionError
=================================== FAILURES ===================================
_________________ test_dataframe_to_sql[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7f7192d32c80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192d32050>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192d32c80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192d32c80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_dataframe_to_sql[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7f718b6fb670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f718b6fb4f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f718b6fb670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f718b6fb670>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_dataframe_to_sql[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f718b7f74f0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_dataframe_to_sql[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7f718b69ed70>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_dataframe_to_sql[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql(conn, test_frame1, request):
        # GH 51086 if conn is sqlite_engine
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine] ___________

self = <pymysql.connections.Connection object at 0x7f71ca579240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca57ae30>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca579240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca579240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn] ____________

self = <pymysql.connections.Connection object at 0x7f71e89a9840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71e89aba60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71e89a9840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71e89a9840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine] ________

self = <sqlalchemy.engine.base.Connection object at 0x7f7192d260e0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________ test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn] _________

self = <sqlalchemy.engine.base.Connection object at 0x7f71e89a9f90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes(conn, request):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "int": pd.array([1], dtype="int8[pyarrow]"),
                "datetime": pd.array(
                    [datetime(2023, 1, 1)], dtype="timestamp[ns][pyarrow]"
                ),
                "date": pd.array([date(2023, 1, 1)], dtype="date32[day][pyarrow]"),
                "timedelta": pd.array([timedelta(1)], dtype="duration[ns][pyarrow]"),
                "string": pd.array(["a"], dtype="string[pyarrow]"),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:569: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7f7192939f30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f719293a4a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192939f30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192939f30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7f71c9d89240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9d88250>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9d89240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9d89240>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9f82200>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7f7193e17340>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]>>
nulls_fixture = None

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7f71c9d2dd20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9d2c460>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9d2dd20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9d2dd20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7f71929687c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f719296bd60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71929687c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71929687c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f7193e16320>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7f7192c21870>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7f7192fbdb70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192fbcf70>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192fbdb70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192fbdb70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7f71caa68520>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71caa681f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71caa68520>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71caa68520>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f7191f93f10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca512590>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]>>
nulls_fixture = NaT

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7f7192ee7460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192ee42e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192ee7460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192ee7460>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7f71ca880c70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca882a10>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca880c70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca880c70>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f7192ff3f40>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7f7192b3c760>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]>>
nulls_fixture = nan

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine] ____

self = <pymysql.connections.Connection object at 0x7f71986e40d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71986e79d0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71986e40d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71986e40d0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn] _____

self = <pymysql.connections.Connection object at 0x7f7192e69d50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192e6ba60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192e69d50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192e69d50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f718b7f5e70>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7f7193264280>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]>>
nulls_fixture = <NA>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine] ___

self = <pymysql.connections.Connection object at 0x7f7192c6cb50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192c6c610>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192c6cb50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192c6cb50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn] ____

self = <pymysql.connections.Connection object at 0x7f71c9ddd600>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9dde020>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9ddd600>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9ddd600>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f718b6bc040>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn] _

self = <sqlalchemy.engine.base.Connection object at 0x7f71caa35780>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]>>
nulls_fixture = Decimal('NaN')

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_dataframe_to_sql_arrow_dtypes_missing(conn, request, nulls_fixture):
        # GH 52046
        pytest.importorskip("pyarrow")
        df = DataFrame(
            {
                "datetime": pd.array(
                    [datetime(2023, 1, 1), nulls_fixture], dtype="timestamp[ns][pyarrow]"
                ),
            }
        )
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ test_to_sql[None-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0x7f71c9e20880>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9e21450>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e20880>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e20880>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_____________________ test_to_sql[None-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0x7f7192b3f100>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192b3cca0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192b3f100>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192b3f100>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________________ test_to_sql[None-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca4c08e0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql[None-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0x7f7198089060>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = None
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[None-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ test_to_sql[multi-mysql_pymysql_engine] ____________________

self = <pymysql.connections.Connection object at 0x7f71e0146f80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71e0145690>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71e0146f80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71e0146f80>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________________ test_to_sql[multi-mysql_pymysql_conn] _____________________

self = <pymysql.connections.Connection object at 0x7f7193221ab0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7193223f40>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193221ab0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193221ab0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql[multi-postgresql_psycopg2_engine] _________________

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca3e0700>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql[multi-postgresql_psycopg2_conn] __________________

self = <sqlalchemy.engine.base.Connection object at 0x7f71cadd02b0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', method = 'multi'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql[multi-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("method", [None, "multi"])
    def test_to_sql(conn, method, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_to_sql_exist[replace-1-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0x7f71931f3cd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71931f10f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71931f3cd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71931f3cd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_exist[replace-1-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0x7f71ca578130>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca5783a0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca578130>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca578130>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________ test_to_sql_exist[replace-1-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9d2ca60>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____________ test_to_sql_exist[replace-1-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0x7f71caebcd00>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'replace', num_row_coef = 1
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[replace-1-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist[append-2-mysql_pymysql_engine] _______________

self = <pymysql.connections.Connection object at 0x7f71c9e05840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9e06ad0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e05840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e05840>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________________ test_to_sql_exist[append-2-mysql_pymysql_conn] ________________

self = <pymysql.connections.Connection object at 0x7f7192c59510>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192c5b4f0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192c59510>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192c59510>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____________ test_to_sql_exist[append-2-postgresql_psycopg2_engine] ____________

self = <sqlalchemy.engine.base.Connection object at 0x7f718b7f6050>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_to_sql_exist[append-2-postgresql_psycopg2_conn] _____________

self = <sqlalchemy.engine.base.Connection object at 0x7f71982ca740>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', mode = 'append', num_row_coef = 2
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist[append-2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    @pytest.mark.parametrize("mode, num_row_coef", [("replace", 1), ("append", 2)])
    def test_to_sql_exist(conn, mode, num_row_coef, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:605: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ test_to_sql_exist_fail[mysql_pymysql_engine] _________________

self = <pymysql.connections.Connection object at 0x7f7193353d30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7193351660>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193353d30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193353d30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_to_sql_exist_fail[mysql_pymysql_conn] __________________

self = <pymysql.connections.Connection object at 0x7f71c9e06c50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9e077c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e06c50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9e06c50>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_to_sql_exist_fail[postgresql_psycopg2_engine] ______________

self = <sqlalchemy.engine.base.Connection object at 0x7f7192b6c310>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ test_to_sql_exist_fail[postgresql_psycopg2_conn] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca0a89a0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_exist_fail[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable)
    def test_to_sql_exist_fail(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:616: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_query[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7f7193e43550>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7193e42b60>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193e43550>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193e43550>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_query[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7f7193205c30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71932066e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193205c30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193205c30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_query[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f719905cc70>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_query[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca86c640>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_query_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0x7f7192cb8400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192cbb190>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192cb8400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192cb8400>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_query_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0x7f71ca987d90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca987700>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca987d90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca987d90>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_query_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0x7f71b9ce28c0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_query_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9dcd330>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_expression_with_parameter[mysql_pymysql_engine] _____

self = <pymysql.connections.Connection object at 0x7f7193066a10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7193064130>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193066a10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7193066a10>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______ test_read_iris_query_expression_with_parameter[mysql_pymysql_conn] ______

self = <pymysql.connections.Connection object at 0x7f71cace99c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71cace8f10>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cace99c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cace99c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine] __

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca3cfbb0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn] ___

self = <sqlalchemy.engine.base.Connection object at 0x7f7192b6e170>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_query_expression_with_parameter(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_______ test_read_iris_query_string_with_parameter[mysql_pymysql_engine] _______

self = <pymysql.connections.Connection object at 0x7f71c9c1f940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9c1c1c0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9c1f940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9c1f940>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
________ test_read_iris_query_string_with_parameter[mysql_pymysql_conn] ________

self = <pymysql.connections.Connection object at 0x7f7191f914b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7191f93970>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7191f914b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[mysql_pymysql_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7191f914b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0x7f7193326fb0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0x7f71cb4107c0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]>>
sql_strings = {'read_named_parameters': {'mysql': '\n                SELECT * FROM iris WHERE\n                `Name`=%(name)s AND `...LECT * FROM iris WHERE "Name"=%s AND "SepalLength"=%s', 'sqlite': 'SELECT * FROM iris WHERE Name=? AND SepalLength=?'}}

    @pytest.mark.db
    @pytest.mark.parametrize("conn", all_connectable_iris)
    def test_read_iris_query_string_with_parameter(conn, request, sql_strings):
        for db, query in sql_strings["read_parameters"].items():
            if db in conn:
                break
        else:
            raise KeyError(f"No part of {conn} found in sql_strings['read_parameters']")
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:682: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_read_iris_table[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7f7192849000>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f719284af50>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192849000>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f7192849000>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_iris_table[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7f71cafea770>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71cafebdc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cafea770>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cafea770>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_read_iris_table[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f71cb425ae0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_read_iris_table[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7f71cab9a740>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table(conn, request):
        # GH 51015 if conn = sqlite_iris_str
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ test_read_iris_table_chunksize[mysql_pymysql_engine] _____________

self = <pymysql.connections.Connection object at 0x7f71cabf2680>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71cabf3940>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cabf2680>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cabf2680>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
______________ test_read_iris_table_chunksize[mysql_pymysql_conn] ______________

self = <pymysql.connections.Connection object at 0x7f71ca4ccfd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca4ce440>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca4ccfd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca4ccfd0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________ test_read_iris_table_chunksize[postgresql_psycopg2_engine] __________

self = <sqlalchemy.engine.base.Connection object at 0x7f7198f80070>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___________ test_read_iris_table_chunksize[postgresql_psycopg2_conn] ___________

self = <sqlalchemy.engine.base.Connection object at 0x7f71cab93f10>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_read_iris_table_chunksize[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable_iris)
    def test_read_iris_table_chunksize(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ test_to_sql_callable[mysql_pymysql_engine] __________________

self = <pymysql.connections.Connection object at 0x7f71929088b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f719290bcd0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71929088b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71929088b0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_to_sql_callable[mysql_pymysql_conn] ___________________

self = <pymysql.connections.Connection object at 0x7f71ca8753c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca875d20>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca8753c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca8753c0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_to_sql_callable[postgresql_psycopg2_engine] _______________

self = <sqlalchemy.engine.base.Connection object at 0x7f71cba8c100>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________________ test_to_sql_callable[postgresql_psycopg2_conn] ________________

self = <sqlalchemy.engine.base.Connection object at 0x7f7192b6ffd0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
test_frame1 =                  index         A         B         C         D
0  2000-01-03 00:00:00  0.980269  3.685731 -0.364217 -1...0-01-05 00:00:00  0.498581  0.731168 -0.537677  1.346270
3  2000-01-06 00:00:00  1.120202  1.567621  0.003641  0.675253
request = <FixtureRequest for <Function test_to_sql_callable[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", sqlalchemy_connectable)
    def test_to_sql_callable(conn, test_frame1, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
______________ test_default_type_conversion[mysql_pymysql_engine] ______________

self = <pymysql.connections.Connection object at 0x7f71ca5ee230>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71ca5ed810>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca5ee230>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71ca5ee230>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_______________ test_default_type_conversion[mysql_pymysql_conn] _______________

self = <pymysql.connections.Connection object at 0x7f719284ae30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f7192849ab0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f719284ae30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_default_type_conversion[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_default_type_conversion(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f719284ae30>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________ test_read_procedure[mysql_pymysql_engine] ___________________

self = <pymysql.connections.Connection object at 0x7f71cb85e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71cb85dcf0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cb85e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71cb85e140>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
___________________ test_read_procedure[mysql_pymysql_conn] ____________________

self = <pymysql.connections.Connection object at 0x7f71988a1d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71988a26e0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71988a1d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_read_procedure[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_read_procedure(conn, request):
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:749: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71988a1d20>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine] ____

self = <sqlalchemy.engine.base.Connection object at 0x7f7190144250>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_____ test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn] _____

self = <sqlalchemy.engine.base.Connection object at 0x7f71cb5b0d90>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 2
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine] _

self = <sqlalchemy.engine.base.Connection object at 0x7f71988a1a20>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
_ test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn] __

self = <sqlalchemy.engine.base.Connection object at 0x7f71cabf2c20>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn', expected_count = 'Success!'
request = <FixtureRequest for <Function test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    @pytest.mark.parametrize("expected_count", [2, "Success!"])
    def test_copy_from_callable_insertion_method(conn, expected_count, request):
        # GH 8953
        # Example in io.rst found under _io.sql.method
        # not available in sqlite, mysql
        def psql_insert_copy(table, conn, keys, data_iter):
            # gets a DBAPI connection that can provide a cursor
            dbapi_conn = conn.connection
            with dbapi_conn.cursor() as cur:
                s_buf = StringIO()
                writer = csv.writer(s_buf)
                writer.writerows(data_iter)
                s_buf.seek(0)
    
                columns = ", ".join([f'"{k}"' for k in keys])
                if table.schema:
                    table_name = f"{table.schema}.{table.name}"
                else:
                    table_name = table.name
    
                sql_query = f"COPY {table_name} ({columns}) FROM STDIN WITH CSV"
                cur.copy_expert(sql=sql_query, file=s_buf)
            return expected_count
    
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:810: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
___ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine] ___

self = <sqlalchemy.engine.base.Connection object at 0x7f7192a68bb0>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
____ test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn] ____

self = <sqlalchemy.engine.base.Connection object at 0x7f7192a9f850>
engine = Engine(postgresql+psycopg2://postgres:***@localhost:5432/pandas)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

conn = 'postgresql_psycopg2_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", postgresql_connectable)
    def test_insertion_method_on_conflict_do_nothing(conn, request):
        # GH 15988: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:437: in postgresql_psycopg2_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=pandas user=postgres password=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'pandas', 'host': 'localhost', 'password': 'postgres', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/psycopg2/__init__.py:122: OperationalError
________ test_insertion_method_on_conflict_update[mysql_pymysql_engine] ________

self = <pymysql.connections.Connection object at 0x7f71c9f7d570>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9f7efe0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9f7d570>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_engine'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_engine]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9f7d570>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
_________ test_insertion_method_on_conflict_update[mysql_pymysql_conn] _________

self = <pymysql.connections.Connection object at 0x7f71c9ee8df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
>                           sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/socket.py:845: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 3306), timeout = 10, source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

/usr/local/lib/python3.10/socket.py:833: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x7f71c9ee9cc0>
engine = Engine(mysql+pymysql://root@localhost:3306/pandas), connection = None
_has_events = None, _allow_revalidate = True, _allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9ee8df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               pymysql.err.OperationalError: (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError

The above exception was the direct cause of the following exception:

conn = 'mysql_pymysql_conn'
request = <FixtureRequest for <Function test_insertion_method_on_conflict_update[mysql_pymysql_conn]>>

    @pytest.mark.db
    @pytest.mark.parametrize("conn", mysql_connectable)
    def test_insertion_method_on_conflict_update(conn, request):
        # GH 14553: Example in to_sql docstring
>       conn = request.getfixturevalue(conn)

pandas/tests/io/test_sql.py:885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1045: in execute
    fixturedef = request._get_active_fixturedef(argname)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py:433: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/pluggy/_manager.py:112: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
/usr/local/lib/python3.10/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
pandas/tests/io/test_sql.py:408: in mysql_pymysql_engine
    insp = sqlalchemy.inspect(engine)
/usr/local/lib/python3.10/site-packages/sqlalchemy/inspection.py:111: in inspect
    ret = reg(subject)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:303: in _engine_insp
    return Inspector._construct(Inspector._init_engine, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:236: in _construct
    init(self, bind)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/reflection.py:247: in _init_engine
    engine.connect().close()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3264: in connect
    return self._connection_cls(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2426: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/base.py:3288: in raw_connection
    return self.pool.connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:1267: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/impl.py:284: in _do_get
    return self._create_connection()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
/usr/local/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: in __exit__
    raise exc_value.with_traceback(exc_tb)
/usr/local/lib/python3.10/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/sqlalchemy/engine/default.py:615: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
/usr/local/lib/python3.10/site-packages/pymysql/connections.py:358: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x7f71c9ee8df0>, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = "Localhost via UNIX socket"
                    self._secure = True
                    if DEBUG:
                        print("connected using unix_socket")
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs["source_address"] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout, **kwargs
                            )
                            break
                        except OSError as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = "socket %s:%d" % (self.host, self.port)
                    if DEBUG:
                        print("connected using socket")
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                sock.settimeout(None)
    
            self._sock = sock
            self._rfile = sock.makefile("rb")
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            # Send "SET NAMES" query on init for:
            # - Ensure charaset (and collation) is set to the server.
            #   - collation_id in handshake packet may be ignored.
            # - If collation is not specified, we don't know what is server's
            #   default collation for the charset. For example, default collation
            #   of utf8mb4 is:
            #   - MySQL 5.7, MariaDB 10.x: utf8mb4_general_ci
            #   - MySQL 8.0: utf8mb4_0900_ai_ci
            #
            # Reference:
            # - https://github.com/PyMySQL/PyMySQL/issues/1092
            # - https://github.com/wagtail/wagtail/issues/9477
            # - https://zenn.dev/methane/articles/2023-mysql-collation (Japanese)
            self.set_character_set(self.charset, self.collation)
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute("SET sql_mode=%s", (self.sql_mode,))
                c.close()
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError)):
                exc = err.OperationalError(
                    CR.CR_CONN_HOST_ERROR,
                    f"Can't connect to MySQL server on {self.host!r} ({e})",
                )
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG:
                    print(exc.traceback)
>               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)")
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

/usr/local/lib/python3.10/site-packages/pymysql/connections.py:711: OperationalError
__________________________ TestS3.test_read_s3_fails ___________________________

self = <aiohttp.connector.TCPConnector object at 0x7f7192c44a30>
req = <aiohttp.client_reqrep.ClientRequest object at 0x7f7193251150>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
>               return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/asyncio/base_events.py:1067: in create_connection
    raise exceptions[0]
/usr/local/lib/python3.10/asyncio/base_events.py:1052: in create_connection
    sock = await self._connect_sock(
/usr/local/lib/python3.10/asyncio/base_events.py:963: in _connect_sock
    await self.sock_connect(sock, address)
/usr/local/lib/python3.10/asyncio/selector_events.py:500: in sock_connect
    return await fut
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=True closed=False debug=False>
fut = <Future finished exception=ConnectionRefusedError(111, "Connect call failed ('127.0.0.1', 5555)")>
sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>
address = ('127.0.0.1', 5555)

    def _sock_connect_cb(self, fut, sock, address):
        if fut.done():
            return
    
        try:
            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
            if err != 0:
                # Jump to any except clause below.
>               raise OSError(err, f'Connect call failed {address}')
E               ConnectionRefusedError: [Errno 111] Connect call failed ('127.0.0.1', 5555)

/usr/local/lib/python3.10/asyncio/selector_events.py:535: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <aiobotocore.httpsession.AIOHTTPSession object at 0x7f71cbf9ad40>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...78ca4f271e', 'amz-sdk-invocation-id': b'e6480321-e9c7-48ec-81a5-757fdb4bce2d', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
>           response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/site-packages/aiohttp/client.py:536: in _request
    conn = await self._connector.connect(
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:540: in connect
    proto = await self._create_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:901: in _create_connection
    _, proto = await self._create_direct_connection(req, traces, timeout)
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1206: in _create_direct_connection
    raise last_exc
/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:1175: in _create_direct_connection
    transp, proto = await self._wrap_create_connection(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiohttp.connector.TCPConnector object at 0x7f7192c44a30>
req = <aiohttp.client_reqrep.ClientRequest object at 0x7f7193251150>
timeout = ClientTimeout(total=None, connect=None, sock_read=15, sock_connect=5)
client_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>
args = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=True closed=False debug=False>), '127.0.0.1', 5555)
kwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}

    async def _wrap_create_connection(
        self,
        *args: Any,
        req: "ClientRequest",
        timeout: "ClientTimeout",
        client_error: Type[Exception] = ClientConnectorError,
        **kwargs: Any,
    ) -> Tuple[asyncio.Transport, ResponseHandler]:
        try:
            async with ceil_timeout(timeout.sock_connect):
                return await self._loop.create_connection(*args, **kwargs)  # type: ignore[return-value]  # noqa
        except cert_errors as exc:
            raise ClientConnectorCertificateError(req.connection_key, exc) from exc
        except ssl_errors as exc:
            raise ClientConnectorSSLError(req.connection_key, exc) from exc
        except OSError as exc:
            if exc.errno is None and isinstance(exc, asyncio.TimeoutError):
                raise
>           raise client_error(req.connection_key, exc) from exc
E           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 127.0.0.1:5555 ssl:default [Connect call failed ('127.0.0.1', 5555)]

/usr/local/lib/python3.10/site-packages/aiohttp/connector.py:988: ClientConnectorError

During handling of the above exception, another exception occurred:

self = <pandas.tests.io.parser.test_network.TestS3 object at 0x7f72923f80a0>
s3so = {'client_kwargs': {'endpoint_url': 'http://127.0.0.1:5555/'}}

    def test_read_s3_fails(self, s3so):
        msg = "The specified bucket does not exist"
        with pytest.raises(OSError, match=msg):
>           read_csv("s3://nyqpug/asdf.csv", storage_options=s3so)

pandas/tests/io/parser/test_network.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/io/parsers/readers.py:945: in read_csv
    return _read(filepath_or_buffer, kwds)
pandas/io/parsers/readers.py:608: in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
pandas/io/parsers/readers.py:1444: in __init__
    self._engine = self._make_engine(f, self.engine)
pandas/io/parsers/readers.py:1701: in _make_engine
    self.handles = get_handle(
pandas/io/common.py:716: in get_handle
    ioargs = _get_filepath_or_buffer(
pandas/io/common.py:418: in _get_filepath_or_buffer
    ).open()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:134: in open
    return self.__enter__()
/usr/local/lib/python3.10/site-packages/fsspec/core.py:102: in __enter__
    f = self.fs.open(self.path, mode=mode)
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1241: in open
    f = self._open(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:659: in _open
    return S3File(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:2066: in __init__
    super().__init__(
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1597: in __init__
    self.size = self.details["size"]
/usr/local/lib/python3.10/site-packages/fsspec/spec.py:1610: in details
    self._details = self.fs.info(self.path)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:121: in wrapper
    return sync(self.loop, func, *args, **kwargs)
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:106: in sync
    raise return_result
/usr/local/lib/python3.10/site-packages/fsspec/asyn.py:61: in _runner
    result[0] = await coro
/usr/local/lib/python3.10/site-packages/s3fs/core.py:1271: in _info
    out = await self._call_s3(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:348: in _call_s3
    return await _error_wrapper(
/usr/local/lib/python3.10/site-packages/s3fs/core.py:140: in _error_wrapper
    raise err
/usr/local/lib/python3.10/site-packages/s3fs/core.py:113: in _error_wrapper
    return await func(*args, **kwargs)
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:361: in _make_api_call
    http, parsed_response = await self._make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/client.py:386: in _make_request
    return await self._endpoint.make_request(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:100: in _send_request
    while await self._needs_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:262: in _needs_retry
    responses = await self._event_emitter.emit(
/usr/local/lib/python3.10/site-packages/aiobotocore/hooks.py:66: in _emit
    response = await resolve_awaitable(handler(**kwargs))
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:107: in _call
    if await resolve_awaitable(self._checker(**checker_kwargs)):
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:126: in _call
    should_retry = await self._should_retry(
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:165: in _should_retry
    return await resolve_awaitable(
/usr/local/lib/python3.10/site-packages/aiobotocore/_helpers.py:15: in resolve_awaitable
    return await obj
/usr/local/lib/python3.10/site-packages/aiobotocore/retryhandler.py:174: in _call
    checker(attempt_number, response, caught_exception)
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:247: in __call__
    return self._check_caught_exception(
/usr/local/lib/python3.10/site-packages/botocore/retryhandler.py:416: in _check_caught_exception
    raise caught_exception
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:181: in _do_get_response
    http_response = await self._send(request)
/usr/local/lib/python3.10/site-packages/aiobotocore/endpoint.py:285: in _send
    return await self.http_session.send(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <aiobotocore.httpsession.AIOHTTPSession object at 0x7f71cbf9ad40>
request = <AWSPreparedRequest stream_output=False, method=HEAD, url=http://127.0.0.1:5555/nyqpug/asdf.csv, headers={'User-Agent'...78ca4f271e', 'amz-sdk-invocation-id': b'e6480321-e9c7-48ec-81a5-757fdb4bce2d', 'amz-sdk-request': b'attempt=5; max=5'}>

    async def send(self, request):
        try:
            proxy_url = self._proxy_config.proxy_url_for(request.url)
            proxy_headers = self._proxy_config.proxy_headers_for(request.url)
            url = request.url
            headers = request.headers
            data = request.body
    
            if ensure_boolean(
                os.environ.get('BOTO_EXPERIMENTAL__ADD_PROXY_HOST_HEADER', '')
            ):
                # This is currently an "experimental" feature which provides
                # no guarantees of backwards compatibility. It may be subject
                # to change or removal in any patch version. Anyone opting in
                # to this feature should strictly pin botocore.
                host = urlparse(request.url).hostname
                proxy_headers['host'] = host
    
            headers_ = CIMultiDict(
                (z[0], _text(z[1], encoding='utf-8')) for z in headers.items()
            )
    
            # https://github.com/boto/botocore/issues/1255
            headers_['Accept-Encoding'] = 'identity'
    
            chunked = None
            if headers_.get('Transfer-Encoding', '').lower() == 'chunked':
                # aiohttp wants chunking as a param, and not a header
                headers_.pop('Transfer-Encoding', '')
                chunked = True
    
            if isinstance(data, io.IOBase):
                data = _IOBaseWrapper(data)
    
            url = URL(url, encoded=True)
            response = await self._session.request(
                request.method,
                url=url,
                chunked=chunked,
                headers=headers_,
                data=data,
                proxy=proxy_url,
                proxy_headers=proxy_headers,
            )
    
            http_response = aiobotocore.awsrequest.AioAWSResponse(
                str(response.url), response.status, response.headers, response
            )
    
            if not request.stream_output:
                # Cause the raw stream to be exhausted immediately. We do it
                # this way instead of using preload_content because
                # preload_content will never buffer chunked responses
                await http_response.content
    
            return http_response
        except ClientSSLError as e:
            raise SSLError(endpoint_url=request.url, error=e)
        except (ClientProxyConnectionError, ClientHttpProxyError) as e:
            raise ProxyConnectionError(
                proxy_url=mask_proxy_url(proxy_url), error=e
            )
        except (
            ServerDisconnectedError,
            aiohttp.ClientPayloadError,
            aiohttp.http_exceptions.BadStatusLine,
        ) as e:
            raise ConnectionClosedError(
                error=e, request=request, endpoint_url=request.url
            )
        except ServerTimeoutError as e:
            if str(e).lower().startswith('connect'):
                raise ConnectTimeoutError(endpoint_url=request.url, error=e)
            else:
                raise ReadTimeoutError(endpoint_url=request.url, error=e)
        except (
            ClientConnectorError,
            ClientConnectionError,
            socket.gaierror,
        ) as e:
>           raise EndpointConnectionError(endpoint_url=request.url, error=e)
E           botocore.exceptions.EndpointConnectionError: Could not connect to the endpoint URL: "http://127.0.0.1:5555/nyqpug/asdf.csv"

/usr/local/lib/python3.10/site-packages/aiobotocore/httpsession.py:253: EndpointConnectionError
=============================== warnings summary ===============================
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
  /usr/local/lib/python3.10/site-packages/seaborn/_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
    if pd.api.types.is_categorical_dtype(vector):

pandas/tests/test_downstream.py::test_seaborn
pandas/tests/test_downstream.py::test_seaborn
  /usr/local/lib/python3.10/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
    with pd.option_context('mode.use_inf_as_na', True):

pandas/tests/arrays/sparse/test_unary.py::TestUnaryMethods::test_neg_operator
pandas/tests/arrays/sparse/test_unary.py::TestUnaryMethods::test_abs_operator
  <__array_function__ internals>:200: RuntimeWarning: invalid value encountered in cast

pandas/tests/extension/test_boolean.py: 1 warning
pandas/tests/extension/test_floating.py: 2 warnings
pandas/tests/extension/test_integer.py: 8 warnings
  /usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py:3464: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

pandas/tests/extension/test_boolean.py: 1 warning
pandas/tests/extension/test_floating.py: 2 warnings
pandas/tests/extension/test_integer.py: 8 warnings
  /usr/local/lib/python3.10/site-packages/numpy/core/_methods.py:184: RuntimeWarning: invalid value encountered in divide
    ret = um.true_divide(

pandas/tests/groupby/test_categorical.py::test_basic
  /usr/local/lib/python3.10/site-packages/numpy/core/fromnumeric.py:84: FutureWarning: The behavior of DataFrame.sum with axis=None is deprecated, in a future version this will reduce over both axes and return a scalar. To retain the old behavior, pass axis=0 (or do not pass axis)
    return reduction(axis=axis, out=out, **passkwargs)

pandas/tests/interchange/test_impl.py::test_empty_pyarrow[data1]
  /usr/local/lib/python3.10/site-packages/numpy/ctypeslib.py:526: RuntimeWarning: A builtin ctypes object gave a PEP3118 format string that does not match its itemsize, so a best-guess will be made of the data type. Newer versions of python may behave correctly.
    return asarray(obj)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
------------- generated xml file: /workspace/pandas/test-data.xml --------------
============================= slowest 30 durations =============================
119.94s call     pandas/tests/io/parser/test_c_parser_only.py::test_bytes_exceed_2gb[c_high]
28.03s call     pandas/tests/io/parser/test_compression.py::test_ignore_compression_extension[pyarrow]
24.35s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='index'-False-True-True-5]
20.49s call     pandas/tests/io/parser/test_network.py::TestS3::test_write_s3_csv_fails
20.44s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='columns'-False-True-True-None]
19.66s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='index'-False-True-True-10]
18.49s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=1-False-True-True-5]
18.43s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=0-False-True-True-10]
18.36s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=0-False-True-True-None]
18.18s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='columns'-False-True-True-5]
18.15s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='columns'-False-True-True-10]
18.05s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=1-False-True-True-None]
18.01s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=1-False-True-True-1]
17.99s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=0-False-True-True-5]
17.94s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='index'-False-True-True-None]
17.93s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=0-False-True-True-2]
17.92s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='columns'-False-True-True-1]
17.90s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='index'-False-True-True-2]
17.90s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=1-False-True-True-2]
17.89s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=1-False-True-True-10]
17.87s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis=0-False-True-True-1]
17.71s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_expanding_apply[axis='columns'-False-True-True]
17.69s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='index'-False-True-True-1]
17.67s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_rolling_apply[axis='columns'-False-True-True-2]
17.64s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_expanding_apply[axis=1-False-True-True]
17.55s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_expanding_apply[axis='index'-False-True-True]
17.54s call     pandas/tests/window/test_numba.py::TestTableMethod::test_table_method_expanding_apply[axis=0-False-True-True]
15.05s call     pandas/tests/window/test_online.py::TestEWM::test_online_vs_non_online_mean[False-True-True-False-False-obj1]
15.05s call     pandas/tests/window/test_online.py::TestEWM::test_online_vs_non_online_mean[False-True-True-True-False-obj1]
14.90s call     pandas/tests/window/test_online.py::TestEWM::test_online_vs_non_online_mean[False-True-True-True-True-obj1]
=========================== short test summary info ============================
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NoneType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float0-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NaTType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[float1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[NAType-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_dataframe_to_sql_arrow_dtypes_missing[Decimal-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_engine] - ...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-mysql_pymysql_conn] - sq...
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[None-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-mysql_pymysql_conn] - s...
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql[multi-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[replace-1-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist[append-2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_exist_fail[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_expression_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_query_string_with_parameter[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_read_iris_table_chunksize[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_to_sql_callable[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_default_type_conversion[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_read_procedure[mysql_pymysql_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[2-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_copy_from_callable_insertion_method[Success!-postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_do_nothing[postgresql_psycopg2_conn]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_engine]
FAILED pandas/tests/io/test_sql.py::test_insertion_method_on_conflict_update[mysql_pymysql_conn]
FAILED pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails - b...
ERROR pandas/tests/io/test_fsspec.py::test_from_s3_csv - botocore.exceptions....
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3] - botocore.except...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3a] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_protocols[s3n] - botocore.excep...
ERROR pandas/tests/io/test_fsspec.py::test_s3_parquet - botocore.exceptions.E...
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_explicit_fs
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col0]
ERROR pandas/tests/io/test_parquet.py::TestParquetPyArrow::test_s3_roundtrip_for_dir[partition_col1]
ERROR pandas/tests/io/test_parquet.py::TestParquetFastParquet::test_s3_roundtrip
ERROR pandas/tests/io/test_s3.py::test_read_without_creds_from_pub_bucket - b...
ERROR pandas/tests/io/test_s3.py::test_read_with_creds_from_pub_bucket - boto...
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_url[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('xlrd', '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('openpyxl', '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xls')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsx')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[(None, '.xlsm')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('pyxlsb', '.xlsb')]
ERROR pandas/tests/io/excel/test_readers.py::TestReaders::test_read_from_s3_object[('odf', '.ods')]
ERROR pandas/tests/io/excel/test_style.py::test_styler_to_s3 - botocore.excep...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[None] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[gzip] - boto...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[bz2] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zip] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[xz] - botoco...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[tar] - botoc...
ERROR pandas/tests/io/json/test_compression.py::test_with_s3_url[zstd] - boto...
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_read_s3_jsonl
ERROR pandas/tests/io/json/test_pandas.py::TestPandasContainer::test_to_s3 - ...
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_private_s3_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3n_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3a_bucket
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_chunked_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_infer_s3_compression
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_parse_public_s3_bucket_nrows_python
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_fails_private
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_handles_boto_s3_object
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_csv_chunked_download
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_s3_with_hash_in_key
ERROR pandas/tests/io/parser/test_network.py::TestS3::test_read_feather_s3_file_path
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[lxml] - b...
ERROR pandas/tests/io/xml/test_to_xml.py::test_s3_permission_output[etree] - ...
ERROR pandas/tests/io/xml/test_xml.py::test_s3_parser_consistency - botocore....
= 93 failed, 216969 passed, 2514 skipped, 2002 xfailed, 13 xpassed, 35 warnings, 56 errors in 3424.09s (0:57:04) =
